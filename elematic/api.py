"""
This file was generated by generateDS.py version 2.43.3, using Python 3.11.8 on Mar 7, 2024.
"""

from __future__ import annotations

from io import StringIO

from itertools import zip_longest
import os
import re
import decimal
from lxml import etree


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        # we ignore comments.
        try:
            parser = etree.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree.XMLParser()
    try:
        if isinstance(infile, os.PathLike):
            infile = os.path.join(infile)
    except AttributeError:
        pass
    doc = etree.parse(infile, parser=parser, **kwargs)
    return doc


def parsexmlstring_(instring, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        # we ignore comments.
        try:
            parser = etree.ETCompatXMLParser()
        except AttributeError:
            # fallback to xml.etree
            parser = etree.XMLParser()
    element = etree.fromstring(instring, parser=parser, **kwargs)
    return element


class GdsCollector(object):

    def __init__(self, messages=None):
        if messages is None:
            self.messages = []
        else:
            self.messages = messages

    def add_message(self, msg):
        self.messages.append(msg)

    def get_messages(self):
        return self.messages

    def clear_messages(self):
        self.messages = []

    def print_messages(self):
        for msg in self.messages:
            print("Warning: {}".format(msg))

    def write_messages(self, outstream):
        for msg in self.messages:
            outstream.write("Warning: {}\n".format(msg))


# The super-class for enum types
try:
    from enum import Enum
except ImportError:
    Enum = object


# The root super-class for element type classes
# Calls to the methods in these classes are generated by generateDS.py.
class GeneratedsSuper:
    __hash__ = object.__hash__

    def __str__(self):
        settings = {
            "str_pretty_print": True,
            "str_indent_level": 0,
            "str_namespaceprefix": "",
            "str_name": self.__class__.__name__,
            "str_namespacedefs": "",
        }
        for n in settings:
            if hasattr(self, n):
                settings[n] = getattr(self, n)
        output = StringIO()
        self.export(  # pylint: disable=no-member
            output,
            settings["str_indent_level"],
            pretty_print=settings["str_pretty_print"],
            namespaceprefix=settings["str_namespaceprefix"],
            name_=settings["str_name"],
            namespacedef=settings["str_namespacedefs"],
        )
        strval = output.getvalue()
        output.close()
        return strval

    def __eq__(self, other):
        def excl_select_objs_(obj):
            return obj[0] != "parent_object_"

        if not isinstance(self, type(other)):
            return False
        return all(
            x == y
            for x, y in zip_longest(
                filter(excl_select_objs_, self.__dict__.items()),
                filter(excl_select_objs_, other.__dict__.items()),
            )
        )

    def __ne__(self, other):
        return not self.__eq__(other)


# Globals
# Set this to false in order to deactivate during export, the use of
# name space prefixes captured from the input document.
UseCapturedNS_ = True
CapturedNsmap_ = {}
Tag_pattern_ = re.compile(r"({.*})?(.*)")
CDATA_pattern_ = re.compile(r"<!\[CDATA\[.*?\]\]>", re.DOTALL)


# Support/utility functions.
def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for _ in range(level):
            outfile.write("    ")


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ""
    s1 = isinstance(inStr, str) and inStr or "%s" % inStr
    s2 = ""
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos : mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start() : mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace("&", "&amp;")
    s1 = s1.replace("<", "&lt;")
    s1 = s1.replace(">", "&gt;")
    return s1


def quote_attrib(inStr):
    s1 = isinstance(inStr, str) and inStr or "%s" % inStr
    s1 = s1.replace("&", "&amp;")
    s1 = s1.replace("<", "&lt;")
    s1 = s1.replace(">", "&gt;")
    s1 = s1.replace("\n", "&#10;")
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ""
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(":")
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        if prefix == "xml":
            namespace = "http://www.w3.org/XML/1998/namespace"
        else:
            namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get(
                "{%s}%s"
                % (
                    namespace,
                    name,
                )
            )
    return value


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)


class ChemicalElementSymbol(str, Enum):
    """
    This datatype enumerates the valid strings representing chemical elements, which may be used in the `Symbol` element.
    """

    H = "H"  # Hydrogen
    HE = "He"  # Helium
    LI = "Li"  # Lithium
    BE = "Be"  # Beryllium
    B = "B"  # Boron
    C = "C"  # Carbon
    N = "N"  # Nitrogen
    O = "O"  # Oxygen
    F = "F"  # Fluorine
    NE = "Ne"  # Neon
    NA = "Na"  # Sodium
    MG = "Mg"  # Magnesium
    AL = "Al"  # Aluminium
    SI = "Si"  # Silicon
    P = "P"  # Phosphorus
    S = "S"  # Sulfur
    CL = "Cl"  # Chlorine
    AR = "Ar"  # Argon
    K = "K"  # Potassium
    CA = "Ca"  # Calcium
    SC = "Sc"  # Scandium
    TI = "Ti"  # Titanium
    V = "V"  # Vanadium
    CR = "Cr"  # Chromium
    MN = "Mn"  # Manganese
    FE = "Fe"  # Iron
    CO = "Co"  # Cobalt
    NI = "Ni"  # Nickel
    CU = "Cu"  # Copper
    ZN = "Zn"  # Zinc
    GA = "Ga"  # Gallium
    GE = "Ge"  # Germanium
    AS = "As"  # Arsenic
    SE = "Se"  # Selenium
    BR = "Br"  # Bromine
    KR = "Kr"  # Krypton
    RB = "Rb"  # Rubidium
    SR = "Sr"  # Strontium
    Y = "Y"  # Yttrium
    ZR = "Zr"  # Zirconium
    NB = "Nb"  # Niobium
    MO = "Mo"  # Molybdenum
    TC = "Tc"  # Technetium
    RU = "Ru"  # Ruthenium
    RH = "Rh"  # Rhodium
    PD = "Pd"  # Palladium
    AG = "Ag"  # Silver
    CD = "Cd"  # Cadmium
    IN = "In"  # Indium
    SN = "Sn"  # Tin
    SB = "Sb"  # Antimony
    TE = "Te"  # Tellurium
    I = "I"  # Iodine
    XE = "Xe"  # Xenon
    CS = "Cs"  # Caesium
    BA = "Ba"  # Barium
    LA = "La"  # Lanthanum
    CE = "Ce"  # Cerium
    PR = "Pr"  # Praseodymium
    ND = "Nd"  # Neodymium
    PM = "Pm"  # Promethium
    SM = "Sm"  # Samarium
    EU = "Eu"  # Europium
    GD = "Gd"  # Gadolinium
    TB = "Tb"  # Terbium
    DY = "Dy"  # Dysprosium
    HO = "Ho"  # Holmium
    ER = "Er"  # Erbium
    TM = "Tm"  # Thulium
    YB = "Yb"  # Ytterbium
    LU = "Lu"  # Lutetium
    HF = "Hf"  # Hafnium
    TA = "Ta"  # Tantalum
    W = "W"  # Tungsten
    RE = "Re"  # Rhenium
    OS = "Os"  # Osmium
    IR = "Ir"  # Iridium
    PT = "Pt"  # Platinum
    AU = "Au"  # Gold
    HG = "Hg"  # Mercury
    TL = "Tl"  # Thallium
    PB = "Pb"  # Lead
    BI = "Bi"  # Bismuth
    PO = "Po"  # Polonium
    AT = "At"  # Astatine
    RN = "Rn"  # Radon
    FR = "Fr"  # Francium
    RA = "Ra"  # Radium
    AC = "Ac"  # Actinium
    TH = "Th"  # Thorium
    PA = "Pa"  # Protactinium
    U = "U"  # Uranium
    NP = "Np"  # Neptunium
    PU = "Pu"  # Plutonium
    AM = "Am"  # Americium
    CM = "Cm"  # Curium
    BK = "Bk"  # Berkelium
    CF = "Cf"  # Californium
    ES = "Es"  # Einsteinium
    FM = "Fm"  # Fermium
    MD = "Md"  # Mendelevium
    NO = "No"  # Nobelium
    LR = "Lr"  # Lawrencium
    RF = "Rf"  # Rutherfordium
    DB = "Db"  # Dubnium
    SG = "Sg"  # Seaborgium
    BH = "Bh"  # Bohrium
    HS = "Hs"  # Hassium
    MT = "Mt"  # Meitnerium
    UUN = "Uun"  # Ununnilium
    UUU = "Uuu"  # Unununium
    UUB = "Uub"  # Ununbium
    UUQ = "Uuq"  # Ununquadium
    UUH = "Uuh"  # Ununhexium
    UUO = "Uuo"  # Ununoctium


class CurrencyCode(str, Enum):
    """ISO4217_CurrencyCode

    Based on ISO-4217, and taken from paper N699 on http://www.jtc1sc32.org/ As of 2003-12-11 permission to use this element has been sought from, but not yet been granted by, the authors of the paper. This element declares the content model for `CurrencyCode`, which contains a string representing a currency. For the most current updates, refer to http://www.din.de/gremien/nas/nabd/iso4217ma/codlistp1/en_listp1.html.
    """

    AFA = "AFA"  # Afghani
    ALL = "ALL"  # Lek
    AMD = "AMD"  # Armenian Dram
    ANG = "ANG"  # Netherlands Antillian Guilder
    AOA = "AOA"  # Kwanza
    ARS = "ARS"  # Argentine Peso
    ATS = "ATS"  # Schilling
    AUD = "AUD"  # Australian Dollar
    AWG = "AWG"  # Aruban Guilder
    AZM = "AZM"  # Azerbaijanian Manat
    BAM = "BAM"  # Convertible Marks
    BBD = "BBD"  # Barbados Dollar
    BDT = "BDT"  # Taka
    BEF = "BEF"  # Belgian Franc
    BGL = "BGL"  # Lev
    BGN = "BGN"  # Bulgarian Lev
    BHD = "BHD"  # Bahraini Dinar
    BIF = "BIF"  # Burundi Franc
    BMD = "BMD"  # Bermudian Dollar
    BND = "BND"  # Brunei Dollar
    BOB = "BOB"  # Boliviano
    BOV = "BOV"  # Mvdol
    BRL = "BRL"  # Brazilian Real
    BSD = "BSD"  # Bahamian Dollar
    BTN = "BTN"  # Ngultrum
    BWP = "BWP"  # Pula
    BYB = "BYB"  # Belarussian Ruble
    BYR = "BYR"  # Belarussian Ruble
    BZD = "BZD"  # Belize Dollar
    CAD = "CAD"  # Canadian Dollar
    CDF = "CDF"  # Franc Congolais
    CHF = "CHF"  # Swiss Franc
    CLF = "CLF"  # Unidades de fomento
    CLP = "CLP"  # Chilean Peso
    CNY = "CNY"  # Yuan Renminbi
    COP = "COP"  # Colombian Peso
    CRC = "CRC"  # Costa Rican Colon
    CUP = "CUP"  # Cuban Peso
    CVE = "CVE"  # Cape Verde Escudo
    CYP = "CYP"  # Cyprus Pound
    CZK = "CZK"  # Czech Koruna
    DEM = "DEM"  # Deutsche Mark
    DJF = "DJF"  # Djibouti Franc
    DKK = "DKK"  # Danish Krone
    DOP = "DOP"  # Dominican Peso
    DZD = "DZD"  # Algerian Dinar
    EEK = "EEK"  # Kroon
    EGP = "EGP"  # Egyptian Pound
    ERN = "ERN"  # Nakfa
    ESP = "ESP"  # Spanish Peseta
    ETB = "ETB"  # Ethiopian Birr
    EUR = "EUR"  # Euro
    FIM = "FIM"  # Markka
    FJD = "FJD"  # Fiji Dollar
    FKP = "FKP"  # Falkland Islands Pound
    FRF = "FRF"  # French Franc
    GBP = "GBP"  # Pound Sterling
    GEL = "GEL"  # Lari
    GHC = "GHC"  # Cedi
    GIP = "GIP"  # Gibraltar Pound
    GMD = "GMD"  # Dalasi
    GNF = "GNF"  # Guinea Franc
    GRD = "GRD"  # Drachma
    GTQ = "GTQ"  # Quetzal
    GWP = "GWP"  # Guinea-Bissau Peso
    GYD = "GYD"  # Guyana Dollar
    HKD = "HKD"  # Hong Kong Dollar
    HNL = "HNL"  # Lempira
    HRK = "HRK"  # Croatian kuna
    HTG = "HTG"  # Gourde
    HUF = "HUF"  # Forint
    IDR = "IDR"  # Rupiah
    IEP = "IEP"  # Irish Pound
    ILS = "ILS"  # New Israeli Sheqel
    INR = "INR"  # Indian Rupee
    IQD = "IQD"  # Iraqi Dinar
    IRR = "IRR"  # Iranian Rial
    ISK = "ISK"  # Iceland Krona
    ITL = "ITL"  # Italian Lira
    JMD = "JMD"  # Jamaican Dollar
    JOD = "JOD"  # Jordanian Dinar
    JPY = "JPY"  # Yen
    KES = "KES"  # Kenyan Shilling
    KGS = "KGS"  # Som
    KHR = "KHR"  # Riel
    KMF = "KMF"  # Comoro Franc
    KPW = "KPW"  # North Korean Won
    KRW = "KRW"  # Won
    KWD = "KWD"  # Kuwaiti Dinar
    KYD = "KYD"  # Cayman Islands Dollar
    KZT = "KZT"  # Tenge
    LAK = "LAK"  # Kip
    LBP = "LBP"  # Lebanese Pound
    LKR = "LKR"  # Sri Lanka Rupee
    LRD = "LRD"  # Liberian Dollar
    LSL = "LSL"  # Loti
    LTL = "LTL"  # Lithuanian Litus
    LUF = "LUF"  # Luxembourg Franc
    LVL = "LVL"  # Latvian Lats
    LYD = "LYD"  # Libyan Dinar
    MAD = "MAD"  # Moroccan Dirham
    MDL = "MDL"  # Moldovan Leu
    MGF = "MGF"  # Malagasy Franc
    MKD = "MKD"  # Denar
    MMK = "MMK"  # Kyat
    MNT = "MNT"  # Tugrik
    MOP = "MOP"  # Pataca
    MRO = "MRO"  # Ouguiya
    MTL = "MTL"  # Maltese Lira
    MUR = "MUR"  # Mauritius Rupee
    MVR = "MVR"  # Rufiyaa
    MWK = "MWK"  # Kwacha
    MXN = "MXN"  # Mexican Peso
    MXV = "MXV"  # Mexican Unidad de Inversion (UDI)
    MYR = "MYR"  # Malaysian Ringgit
    MZM = "MZM"  # Metical
    NAD = "NAD"  # Namibia Dollar
    NGN = "NGN"  # Naira
    NIO = "NIO"  # Cordoba Oro
    NLG = "NLG"  # Netherlands Guilder
    NOK = "NOK"  # Norwegian Krone
    NPR = "NPR"  # Nepalese Rupee
    NZD = "NZD"  # New Zealand Dollar
    OMR = "OMR"  # Rial Omani
    PAB = "PAB"  # Balboa
    PEN = "PEN"  # Nuevo Sol
    PGK = "PGK"  # Kina
    PHP = "PHP"  # Philippine Peso
    PKR = "PKR"  # Pakistan Rupee
    PLN = "PLN"  # Zloty
    PTE = "PTE"  # Portuguese Escudo
    PYG = "PYG"  # Guarani
    QAR = "QAR"  # Qatari Rial
    ROL = "ROL"  # Leu
    RUB = "RUB"  # Russian Ruble
    RUR = "RUR"  # Russian Ruble
    RWF = "RWF"  # Rwanda Franc
    SAR = "SAR"  # Saudi Riyal
    SBD = "SBD"  # Solomon Islands Dollar
    SCR = "SCR"  # Seychelles Rupee
    SDD = "SDD"  # Sudanese Dinar
    SEK = "SEK"  # Swedish Krona
    SGD = "SGD"  # Singapore Dollar
    SHP = "SHP"  # Saint Helena Pound
    SIT = "SIT"  # Tolar
    SKK = "SKK"  # Slovak Koruna
    SLL = "SLL"  # Leone
    SOS = "SOS"  # Somali Shilling
    SRG = "SRG"  # Suriname Guilder
    STD = "STD"  # Dobra
    SVC = "SVC"  # El Salvador Colon
    SYP = "SYP"  # Syrian Pound
    SZL = "SZL"  # Lilangeni
    THB = "THB"  # Baht
    TJR = "TJR"  # Tajik Ruble
    TMM = "TMM"  # Manat
    TND = "TND"  # Tunisian Dinar
    TOP = "TOP"  # Paâ€™anga
    TPE = "TPE"  # Timor Escudo
    TRL = "TRL"  # Turkish Lira
    TTD = "TTD"  # Trinidad and Tobago Dollar
    TWD = "TWD"  # New Taiwan Dollar
    TZS = "TZS"  # Tanzanian Shilling
    UAH = "UAH"  # Hryvnia
    UGX = "UGX"  # Uganda Shilling
    USD = "USD"  # US Dollar
    UYU = "UYU"  # Peso Uruguayo
    UZS = "UZS"  # Uzbekistan Sum
    VEB = "VEB"  # Bolivar
    VND = "VND"  # Dong
    VUV = "VUV"  # Vatu
    WST = "WST"  # Tala
    XAF = "XAF"  # CFA Franc BEAC
    XCD = "XCD"  # East Caribbean Dollar
    XDR = "XDR"  # SDR
    XOF = "XOF"  # CFA Franc BCEAO
    XPF = "XPF"  # CFP Franc
    YER = "YER"  # Yemeni Rial
    YUM = "YUM"  # Yugoslavian Dinar
    ZAR = "ZAR"  # Rand
    ZMK = "ZMK"  # Kwacha
    ZWD = "ZWD"  # Zimbabwe Dollar


class DataFormat(str, Enum):
    """This element declares the content model for `DataFormat` and is composed of the following elements. `DataFormat` is used to indicate the format of a value with which it is associated ("float," "integer," "string,", "exponential" or "mixed") "mixed" is only used for a group of data where each individual member of the group can be given a unique format."""

    FLOAT = "float"
    INTEGER = "integer"
    STRING = "string"
    EXPONENTIAL = "exponential"
    MIXED = "mixed"


class ScaleType(str, Enum):
    LINEAR = "Linear"
    LOGARITHMIC = "Logarithmic"


class MatML_Doc(GeneratedsSuper):
    """This element declares the content model for `MatML_Doc`, topmost in the hierarchy of elements that comprise a document marked up using MatML. Content models describe the relationships of the element and its child elements.

    - `MatML_Doc` must contain one or more `Material` elements.

    - `Metadata` contains descriptions of the data sources, properties, measurement techniques, specimens, and parameters which are referenced when materials property data are encoded using other elements. `Metadata` may occur once or not at all within the Material element. For more information, see the documentation for the `Metadata` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Material=None,
        Metadata=None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        if Material is None:
            self.Material = []
        else:
            self.Material = Material
        self.Material_nsprefix_ = None
        self.Metadata = Metadata
        self.Metadata_nsprefix_ = None

    def factory(*args_, **kwargs):

        return MatML_Doc(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Material(self, id=None):
        if id is not None:
            for material in self.get_Material():
                if material.get_id() == id:
                    return material
            return None
        return self.Material

    def set_Material(self, Material):
        self.Material = Material

    def add_Material(self, value):
        self.Material.append(value)

    def insert_Material_at(self, index, value):
        self.Material.insert(index, value)

    def replace_Material_at(self, index, value):
        self.Material[index] = value

    MaterialProp = property(get_Material, set_Material)

    def get_Metadata(self):
        return self.Metadata

    def set_Metadata(self, Metadata):
        self.Metadata = Metadata

    MetadataProp = property(get_Metadata, set_Metadata)

    def has__content(self):
        if self.Material or self.Metadata is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="MatML_Doc",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "MatML_Doc":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        pretty_print=True,
    ):
        for Material_ in self.Material:
            namespaceprefix = (
                self.Material_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Material_nsprefix_)
                else ""
            )
            Material_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Material",
                pretty_print=pretty_print,
            )
        if self.Metadata is not None:
            namespaceprefix = (
                self.Metadata_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Metadata_nsprefix_)
                else ""
            )
            self.Metadata.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Metadata",
                pretty_print=pretty_print,
            )

    def build(self, node):


        self.ns_prefix_ = node.prefix
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, nodeName)
        return self

    def _buildChildren(self, child_, nodeName):
        if nodeName == "Material":
            obj_ = Material.factory(parent_object_=self)
            obj_.build(child_)
            self.Material.append(obj_)
            obj_.original_tagname_ = "Material"
        elif nodeName == "Metadata":
            obj_ = Metadata.factory(parent_object_=self)
            obj_.build(child_)
            self.Metadata = obj_
            obj_.original_tagname_ = "Metadata"


class AssociationDetails(GeneratedsSuper):
    """This element declares the content model for `AssociationDetails`, which contains a description of a relationship of the component to another component in a complex material system such as a composite, weld, or multilayer material. `AssociationDetails` is composed of the following elements.

    - `Associate` contains the name of a component's associate. For example, a TiC coating has been placed on AISI 1018 steel coupons. The `Associate` of the steel, then, is the "titanium carbide coating." `Associate` must occur once and only once within the `AssociationDetails` element.
    - `Relationship` contains a description of the relationship between a component and the associate. For example, the associate of the "steel" component is the "titanium carbide coating." The relationship of the "steel" to the "titanium carbide coating" is that the steel is the "substrate" for the coating. `Relationship` must occur once and only once within the `AssociationDetails` element.
    - `Notes` contains any additional information concerning the association and may occur once or not at all within the `AssociationDetails` element.

    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Associate: str = None,
        Relationship: str = None,
        Notes=None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Associate = Associate
        self.Associate_nsprefix_ = None
        self.Relationship = Relationship
        self.Relationship_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return AssociationDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Associate(self):
        return self.Associate

    def set_Associate(self, Associate):
        self.Associate = Associate

    AssociateProp = property(get_Associate, set_Associate)

    def get_Relationship(self):
        return self.Relationship

    def set_Relationship(self, Relationship):
        self.Relationship = Relationship

    RelationshipProp = property(get_Relationship, set_Relationship)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Associate is not None
            or self.Relationship is not None
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="AssociationDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "AssociationDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        

        if self.has__content():
            outfile.write(">%s" % (eol,))

            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        
        
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Associate is not None:
            namespaceprefix = (
                self.Associate_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Associate_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sAssociate>%s</%sAssociate>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Associate),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Relationship is not None:
            namespaceprefix = (
                self.Relationship_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Relationship_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sRelationship>%s</%sRelationship>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Relationship),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):


        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, nodeName)
        return self

    def _buildChildren(self, child_, nodeName,):
        if nodeName == "Associate":
            value_ = child_.text
            self.Associate = value_
            self.Associate_nsprefix_ = child_.prefix
        elif nodeName == "Relationship":
            value_ = child_.text
            self.Relationship = value_
            self.Relationship_nsprefix_ = child_.prefix
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class BulkDetails(GeneratedsSuper):
    """This element declares the content model for `BulkDetails`, which contains a description of the bulk material and is composed of the following elements.

    - `Name` contains the material's name and has one optional attribute, `authority`, for identifying an authoritative source of material names. `Name` must occur once and only once within the `BulkDetails` element.
    - `Class` contains the material's class and may occur zero or more times within the `BulkDetails` element.
    - `Subclass` contains the material's subclass(es) and may occur zero or more times within the `BulkDetails` element.
    - `Specification` contains the material's specification(s) and has one optional attribute, `authority`, for identifying an authoritative source of material specifications. `Specification` may occur zero or more times within the `BulkDetails` element.
    - `Source` contains the name of the source of the material and may occur once or not at all within the `BulkDetails` element.
    - `Form` contains the form of the material and may occur once or not at all within the `BulkDetails` element. It has an optional element `Geometry`, for describing the dimensions of the Component.  For additional information, see the documentation for the `Form` type.
    - `ProcessingDetails` contains a description of a processing step for the material and may occur zero or more times within the `BulkDetails` element. For additional information, see the documentation for the `ProcessingDetails` element.
    - `Characterization` contains the characterization of the material, including the formula, chemical composition, phase composition, and dimensional details. `Characterization` may occur once or not at all within the `BulkDetails` element. For additional information, see the documentation for the `Characterization` element.
    - `PropertyData` contains the property data for the material and may occur zero or more times within the `BulkDetails` element. For additional information, see the documentation for the `PropertyData` element.
    - `Notes` contains any additional information concerning the bulk material and may occur once or not at all within the `BulkDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Name: Name = None,
        Class: Class = None,
        Subclass: Class = None,
        Specification: Specification = None,
        Source: Source = None,
        Form: Form = None,
        ProcessingDetails: ProcessingDetails = None,
        Characterization: Characterization = None,
        PropertyData: PropertyData = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        if Class is None:
            self.Class = []
        else:
            self.Class = Class
        self.Class_nsprefix_ = None
        if Subclass is None:
            self.Subclass = []
        else:
            self.Subclass = Subclass
        self.Subclass_nsprefix_ = None
        if Specification is None:
            self.Specification = []
        else:
            self.Specification = Specification
        self.Specification_nsprefix_ = None
        self.Source = Source
        self.Source_nsprefix_ = None
        self.Form = Form
        self.Form_nsprefix_ = None
        if ProcessingDetails is None:
            self.ProcessingDetails = []
        else:
            self.ProcessingDetails = ProcessingDetails
        self.ProcessingDetails_nsprefix_ = None
        self.Characterization = Characterization
        self.Characterization_nsprefix_ = None
        if PropertyData is None:
            self.PropertyData = []
        else:
            self.PropertyData = PropertyData
        self.PropertyData_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return BulkDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Class(self):
        return self.Class

    def set_Class(self, Class):
        self.Class = Class

    def add_Class(self, value):
        self.Class.append(value)

    def insert_Class_at(self, index, value):
        self.Class.insert(index, value)

    def replace_Class_at(self, index, value):
        self.Class[index] = value

    ClassProp = property(get_Class, set_Class)

    def get_Subclass(self):
        return self.Subclass

    def set_Subclass(self, Subclass):
        self.Subclass = Subclass

    def add_Subclass(self, value):
        self.Subclass.append(value)

    def insert_Subclass_at(self, index, value):
        self.Subclass.insert(index, value)

    def replace_Subclass_at(self, index, value):
        self.Subclass[index] = value

    SubclassProp = property(get_Subclass, set_Subclass)

    def get_Specification(self):
        return self.Specification

    def set_Specification(self, Specification):
        self.Specification = Specification

    def add_Specification(self, value):
        self.Specification.append(value)

    def insert_Specification_at(self, index, value):
        self.Specification.insert(index, value)

    def replace_Specification_at(self, index, value):
        self.Specification[index] = value

    SpecificationProp = property(get_Specification, set_Specification)

    def get_Source(self):
        return self.Source

    def set_Source(self, Source):
        self.Source = Source

    SourceProp = property(get_Source, set_Source)

    def get_Form(self):
        return self.Form

    def set_Form(self, Form):
        self.Form = Form

    FormProp = property(get_Form, set_Form)

    def get_ProcessingDetails(self):
        return self.ProcessingDetails

    def set_ProcessingDetails(self, ProcessingDetails):
        self.ProcessingDetails = ProcessingDetails

    def add_ProcessingDetails(self, value):
        self.ProcessingDetails.append(value)

    def insert_ProcessingDetails_at(self, index, value):
        self.ProcessingDetails.insert(index, value)

    def replace_ProcessingDetails_at(self, index, value):
        self.ProcessingDetails[index] = value

    ProcessingDetailsProp = property(get_ProcessingDetails, set_ProcessingDetails)

    def get_Characterization(self):
        return self.Characterization

    def set_Characterization(self, Characterization):
        self.Characterization = Characterization

    CharacterizationProp = property(get_Characterization, set_Characterization)

    def get_PropertyData(self, property=None):
        if property is not None:
            properties = []
            for property_data in self.get_PropertyData():
                if property_data.get_property() == property:
                    properties.append(property_data)
            return properties
        return self.PropertyData

    def set_PropertyData(self, PropertyData):
        self.PropertyData = PropertyData

    def add_PropertyData(self, value):
        self.PropertyData.append(value)

    def insert_PropertyData_at(self, index, value):
        self.PropertyData.insert(index, value)

    def replace_PropertyData_at(self, index, value):
        self.PropertyData[index] = value

    PropertyDataProp = property(get_PropertyData, set_PropertyData)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Name is not None
            or self.Class
            or self.Subclass
            or self.Specification
            or self.Source is not None
            or self.Form is not None
            or self.ProcessingDetails
            or self.Characterization is not None
            or self.PropertyData
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="BulkDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "BulkDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="BulkDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="BulkDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        for Class_ in self.Class:
            namespaceprefix = (
                self.Class_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Class_nsprefix_)
                else ""
            )
            Class_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Class",
                pretty_print=pretty_print,
            )
        for Subclass_ in self.Subclass:
            namespaceprefix = (
                self.Subclass_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Subclass_nsprefix_)
                else ""
            )
            Subclass_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Subclass",
                pretty_print=pretty_print,
            )
        for Specification_ in self.Specification:
            namespaceprefix = (
                self.Specification_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Specification_nsprefix_)
                else ""
            )
            Specification_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Specification",
                pretty_print=pretty_print,
            )
        if self.Source is not None:
            namespaceprefix = (
                self.Source_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Source_nsprefix_)
                else ""
            )
            self.Source.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Source",
                pretty_print=pretty_print,
            )
        if self.Form is not None:
            namespaceprefix = (
                self.Form_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Form_nsprefix_)
                else ""
            )
            self.Form.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Form",
                pretty_print=pretty_print,
            )
        for ProcessingDetails_ in self.ProcessingDetails:
            namespaceprefix = (
                self.ProcessingDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ProcessingDetails_nsprefix_)
                else ""
            )
            ProcessingDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ProcessingDetails",
                pretty_print=pretty_print,
            )
        if self.Characterization is not None:
            namespaceprefix = (
                self.Characterization_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Characterization_nsprefix_)
                else ""
            )
            self.Characterization.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Characterization",
                pretty_print=pretty_print,
            )
        for PropertyData_ in self.PropertyData:
            namespaceprefix = (
                self.PropertyData_nsprefix_ + ":"
                if (UseCapturedNS_ and self.PropertyData_nsprefix_)
                else ""
            )
            PropertyData_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="PropertyData",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Class":
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_)
            self.Class.append(obj_)
            obj_.original_tagname_ = "Class"
        elif nodeName == "Subclass":
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_)
            self.Subclass.append(obj_)
            obj_.original_tagname_ = "Subclass"
        elif nodeName == "Specification":
            obj_ = Specification.factory(parent_object_=self)
            obj_.build(child_)
            self.Specification.append(obj_)
            obj_.original_tagname_ = "Specification"
        elif nodeName == "Source":
            obj_ = Source.factory(parent_object_=self)
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = "Source"
        elif nodeName == "Form":
            obj_ = Form.factory(parent_object_=self)
            obj_.build(child_)
            self.Form = obj_
            obj_.original_tagname_ = "Form"
        elif nodeName == "ProcessingDetails":
            obj_ = ProcessingDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.ProcessingDetails.append(obj_)
            obj_.original_tagname_ = "ProcessingDetails"
        elif nodeName == "Characterization":
            obj_ = Characterization.factory(parent_object_=self)
            obj_.build(child_)
            self.Characterization = obj_
            obj_.original_tagname_ = "Characterization"
        elif nodeName == "PropertyData":
            obj_ = PropertyData.factory(parent_object_=self)
            obj_.build(child_)
            self.PropertyData.append(obj_)
            obj_.original_tagname_ = "PropertyData"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class Characterization(GeneratedsSuper):
    """This element declares the content model for `Characterization`, which contains a description of the chemical composition of the bulk material or component and is composed of the following elements.

    - `Formula` contains a string representation of the chemical formula for the bulk material or component and must occur once and only once within the `Characterization` element.  For further details see documentation of the `Formula` element.
    - `ChemicalComposition` contains a description of the compounds and elements that comprise the bulk material or component and may occur once or not at all within the `Characterization` element. For additional information, see the documentation for the `ChemicalComposition` element.
    - `PhaseComposition` contains a description of the phases that comprise the bulk material or component and may occur zero or more times within the `Characterization` element. For additional information, see the documentation for the `PhaseComposition` element.
    - `DimensionalDetails` contains information relating to component or bulk material dimensional characteristics such as grain size, porosity, precipitate size and distribution, etc., and may occur zero or more times within the `Characterization` element. For additional information, see the documentation for the `DimensionalDetails` element.
    - `Notes` contains any additional information concerning the `Characterization` and may occur once or not at all within the `Characterization` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Formula: str = None,
        ChemicalComposition: ChemicalComposition = None,
        PhaseComposition: Name = None,
        DimensionalDetails: DimensionalDetails = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Formula = Formula
        self.Formula_nsprefix_ = None
        self.ChemicalComposition = ChemicalComposition
        self.ChemicalComposition_nsprefix_ = None
        if PhaseComposition is None:
            self.PhaseComposition = []
        else:
            self.PhaseComposition = PhaseComposition
        self.PhaseComposition_nsprefix_ = None
        if DimensionalDetails is None:
            self.DimensionalDetails = []
        else:
            self.DimensionalDetails = DimensionalDetails
        self.DimensionalDetails_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Characterization(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Formula(self):
        return self.Formula

    def set_Formula(self, Formula):
        self.Formula = Formula

    FormulaProp = property(get_Formula, set_Formula)

    def get_ChemicalComposition(self):
        return self.ChemicalComposition

    def set_ChemicalComposition(self, ChemicalComposition):
        self.ChemicalComposition = ChemicalComposition

    ChemicalCompositionProp = property(get_ChemicalComposition, set_ChemicalComposition)

    def get_PhaseComposition(self):
        return self.PhaseComposition

    def set_PhaseComposition(self, PhaseComposition):
        self.PhaseComposition = PhaseComposition

    def add_PhaseComposition(self, value):
        self.PhaseComposition.append(value)

    def insert_PhaseComposition_at(self, index, value):
        self.PhaseComposition.insert(index, value)

    def replace_PhaseComposition_at(self, index, value):
        self.PhaseComposition[index] = value

    PhaseCompositionProp = property(get_PhaseComposition, set_PhaseComposition)

    def get_DimensionalDetails(self):
        return self.DimensionalDetails

    def set_DimensionalDetails(self, DimensionalDetails):
        self.DimensionalDetails = DimensionalDetails

    def add_DimensionalDetails(self, value):
        self.DimensionalDetails.append(value)

    def insert_DimensionalDetails_at(self, index, value):
        self.DimensionalDetails.insert(index, value)

    def replace_DimensionalDetails_at(self, index, value):
        self.DimensionalDetails[index] = value

    DimensionalDetailsProp = property(get_DimensionalDetails, set_DimensionalDetails)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Formula is not None
            or self.ChemicalComposition is not None
            or self.PhaseComposition
            or self.DimensionalDetails
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Characterization",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Characterization":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Characterization",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Characterization",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Formula is not None:
            namespaceprefix = (
                self.Formula_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Formula_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sFormula>%s</%sFormula>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Formula),
                    namespaceprefix,
                    eol,
                )
            )
        if self.ChemicalComposition is not None:
            namespaceprefix = (
                self.ChemicalComposition_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ChemicalComposition_nsprefix_)
                else ""
            )
            self.ChemicalComposition.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ChemicalComposition",
                pretty_print=pretty_print,
            )
        for PhaseComposition_ in self.PhaseComposition:
            namespaceprefix = (
                self.PhaseComposition_nsprefix_ + ":"
                if (UseCapturedNS_ and self.PhaseComposition_nsprefix_)
                else ""
            )
            PhaseComposition_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="PhaseComposition",
                pretty_print=pretty_print,
            )
        for DimensionalDetails_ in self.DimensionalDetails:
            namespaceprefix = (
                self.DimensionalDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.DimensionalDetails_nsprefix_)
                else ""
            )
            DimensionalDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="DimensionalDetails",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Formula":
            value_ = child_.text

            self.Formula = value_
            self.Formula_nsprefix_ = child_.prefix
        elif nodeName == "ChemicalComposition":
            obj_ = ChemicalComposition.factory(parent_object_=self)
            obj_.build(child_)
            self.ChemicalComposition = obj_
            obj_.original_tagname_ = "ChemicalComposition"
        elif nodeName == "PhaseComposition":
            obj_ = PhaseComposition.factory(parent_object_=self)
            obj_.build(child_)
            self.PhaseComposition.append(obj_)
            obj_.original_tagname_ = "PhaseComposition"
        elif nodeName == "DimensionalDetails":
            obj_ = DimensionalDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.DimensionalDetails.append(obj_)
            obj_.original_tagname_ = "DimensionalDetails"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class ChemicalComposition(GeneratedsSuper):
    """This element declares the content model for `ChemicalComposition`, which contains a detailed description of the compounds and elements that comprise the bulk material or component. `ChemicalComposition` must contain at least one `Compound` element or `Element` element but may contain as many of each element as needed.

    - `Compound` contains a description of a compound. For additional information, see the documentation for the `Compound` element.
    - `Element` contains a description of an element. For additional information, see the documentation for the `Element` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Compound: Compound = None,
        Element: Element = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        if Compound is None:
            self.Compound = []
        else:
            self.Compound = Compound
        self.Compound_nsprefix_ = None
        if Element is None:
            self.Element = []
        else:
            self.Element = Element
        self.Element_nsprefix_ = None

    def factory(*args_, **kwargs):

        return ChemicalComposition(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Compound(self):
        return self.Compound

    def set_Compound(self, Compound):
        self.Compound = Compound

    def add_Compound(self, value):
        self.Compound.append(value)

    def insert_Compound_at(self, index, value):
        self.Compound.insert(index, value)

    def replace_Compound_at(self, index, value):
        self.Compound[index] = value

    CompoundProp = property(get_Compound, set_Compound)

    def get_Element(self):
        return self.Element

    def set_Element(self, Element):
        self.Element = Element

    def add_Element(self, value):
        self.Element.append(value)

    def insert_Element_at(self, index, value):
        self.Element.insert(index, value)

    def replace_Element_at(self, index, value):
        self.Element[index] = value

    ElementProp = property(get_Element, set_Element)

    def has__content(self):
        if self.Compound or self.Element:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ChemicalComposition",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "ChemicalComposition":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="ChemicalComposition",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ChemicalComposition",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        for Compound_ in self.Compound:
            namespaceprefix = (
                self.Compound_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Compound_nsprefix_)
                else ""
            )
            Compound_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Compound",
                pretty_print=pretty_print,
            )
        for Element_ in self.Element:
            namespaceprefix = (
                self.Element_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Element_nsprefix_)
                else ""
            )
            Element_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Element",
                pretty_print=pretty_print,
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Compound":
            obj_ = Compound.factory(parent_object_=self)
            obj_.build(child_)
            self.Compound.append(obj_)
            obj_.original_tagname_ = "Compound"
        elif nodeName == "Element":
            obj_ = Element.factory(parent_object_=self)
            obj_.build(child_)
            self.Element.append(obj_)
            obj_.original_tagname_ = "Element"


class Class(GeneratedsSuper):
    """This element declares the content model for `Class`, which is the material class to which the `Material` belongs.

    The `Class` can either have a `Name` or `ParentMaterial` element:

    - `Name` contains a string representing the name of the material's class and may occur only once within the `Class` element.
    - `ParentMaterial` is a reference by `id` to another `Material` in the `MatML_Doc` and can occur only once in the `Class` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Name: Name = None,
        ParentMaterial: ParentMaterialType = None,
        ParentSubClass: Class = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        if ParentMaterial is None:
            self.ParentMaterial = []
        else:
            self.ParentMaterial = ParentMaterial
        self.ParentMaterial_nsprefix_ = None
        if ParentSubClass is None:
            self.ParentSubClass = []
        else:
            self.ParentSubClass = ParentSubClass
        self.ParentSubClass_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Class(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_ParentMaterial(self):
        return self.ParentMaterial

    def set_ParentMaterial(self, ParentMaterial):
        self.ParentMaterial = ParentMaterial

    def add_ParentMaterial(self, value):
        self.ParentMaterial.append(value)

    def insert_ParentMaterial_at(self, index, value):
        self.ParentMaterial.insert(index, value)

    def replace_ParentMaterial_at(self, index, value):
        self.ParentMaterial[index] = value

    ParentMaterialProp = property(get_ParentMaterial, set_ParentMaterial)

    def get_ParentSubClass(self):
        return self.ParentSubClass

    def set_ParentSubClass(self, ParentSubClass):
        self.ParentSubClass = ParentSubClass

    def add_ParentSubClass(self, value):
        self.ParentSubClass.append(value)

    def insert_ParentSubClass_at(self, index, value):
        self.ParentSubClass.insert(index, value)

    def replace_ParentSubClass_at(self, index, value):
        self.ParentSubClass[index] = value

    ParentSubClassProp = property(get_ParentSubClass, set_ParentSubClass)

    def has__content(self):
        if self.Name is not None or self.ParentMaterial or self.ParentSubClass:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Class",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Class":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Class",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Class",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        for ParentMaterial_ in self.ParentMaterial:
            namespaceprefix = (
                self.ParentMaterial_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ParentMaterial_nsprefix_)
                else ""
            )
            ParentMaterial_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ParentMaterial",
                pretty_print=pretty_print,
            )
        for ParentSubClass_ in self.ParentSubClass:
            namespaceprefix = (
                self.ParentSubClass_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ParentSubClass_nsprefix_)
                else ""
            )
            ParentSubClass_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ParentSubClass",
                pretty_print=pretty_print,
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "ParentMaterial":
            obj_ = ParentMaterialType.factory(parent_object_=self)
            obj_.build(child_)
            self.ParentMaterial.append(obj_)
            obj_.original_tagname_ = "ParentMaterial"
        elif nodeName == "ParentSubClass":
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_)
            self.ParentSubClass.append(obj_)
            obj_.original_tagname_ = "ParentSubClass"


class ComponentDetails(GeneratedsSuper):
    """This element declares the content model for `ComponentDetails`, which contains a description of a component within the bulk material and has one optional attribute, `id`, which may be used as an identification specifier for the component and is especially useful for complex systems such as composite laminates.

    `ComponentDetails` is composed of the following elements.

    - `Name` contains the component's name and has one optional attribute, `authority`, for identifying an authoritative source of component names. `Name` must occur once and only once within the `ComponentDetails` type.
    - `Class` contains the component's class and may occur zero or more times within the `ComponentDetails` element.  For additional information, see the documentation for the `Class` type.
    - `Subclass` contains the component's subclass(es) and may occur zero or more times within the `ComponentDetails` element. For additional information, see the documentation for the `SubClass` type.
    - `Specification` contains the component's specification(s) and has one optional attribute, `authority`, for identifying an authoritative source of component specifications. `Specification` may occur zero or more times within the `ComponentDetails` type.
    - `Source` contains the name of the source of the component and may occur once or not at all within the `ComponentDetails` type.  For additional information, see the documentation for the `SourceDetails` element.
    - `Form` contains the form of the component and may occur once or not at all within the `ComponentDetails` type.  It has an optional element `Geometry`, for describing the dimensions of the Component.  For additional information, see the documentation for the `Form` type.
    - `ProcessingDetails` contains a description of a processing step for the component and may occur zero or more times within the `ComponentDetails` type. For additional information, see the documentation for the `ProcessingDetails` element.
    - `Characterization` contains the characterization of the component, including the formula, chemical composition, phase composition, and dimensional details. `Characterization` may occur once or not at all within the `ComponentDetails` type. For additional information, see the documentation for the `Characterization` element.
    - `PropertyData` contains the property data for the component and may occur zero or more times within the `ComponentDetails` type. For additional information, see the documentation for the `PropertyData` element.
    - `AssociationDetails` contains a description of a relationship of the component to another component and may occur zero or more times within the `ComponentDetails` type. For additional information, see the documentation for the `AssociationDetails` element. Notes contains any additional information concerning the component and may occur once or not at all within the `ComponentDetails` type.
    - `ComponentDetails` contains a description of a component within the component and is used to support encoding of information for complex materials systems such as composites. `ComponentDetails` may occur zero or more times within a `ComponentDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        id: str = None,
        Name: Name = None,
        Class: Class = None,
        Subclass: Class = None,
        Specification: Specification = None,
        Source: Source = None,
        Form: Form = None,
        ProcessingDetails: ProcessingDetails = None,
        Characterization: Characterization = None,
        PropertyData: PropertyData = None,
        AssociationDetails: AssociationDetails = None,
        ComponentDetails_member: ComponentDetails = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        if Class is None:
            self.Class = []
        else:
            self.Class = Class
        self.Class_nsprefix_ = None
        if Subclass is None:
            self.Subclass = []
        else:
            self.Subclass = Subclass
        self.Subclass_nsprefix_ = None
        if Specification is None:
            self.Specification = []
        else:
            self.Specification = Specification
        self.Specification_nsprefix_ = None
        self.Source = Source
        self.Source_nsprefix_ = None
        self.Form = Form
        self.Form_nsprefix_ = None
        if ProcessingDetails is None:
            self.ProcessingDetails = []
        else:
            self.ProcessingDetails = ProcessingDetails
        self.ProcessingDetails_nsprefix_ = None
        self.Characterization = Characterization
        self.Characterization_nsprefix_ = None
        if PropertyData is None:
            self.PropertyData = []
        else:
            self.PropertyData = PropertyData
        self.PropertyData_nsprefix_ = None
        if AssociationDetails is None:
            self.AssociationDetails = []
        else:
            self.AssociationDetails = AssociationDetails
        self.AssociationDetails_nsprefix_ = None
        if ComponentDetails_member is None:
            self.ComponentDetails = []
        else:
            self.ComponentDetails = ComponentDetails_member
        self.ComponentDetails_nsprefix_ = None

    def factory(*args_, **kwargs):

        return ComponentDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Class(self):
        return self.Class

    def set_Class(self, Class):
        self.Class = Class

    def add_Class(self, value):
        self.Class.append(value)

    def insert_Class_at(self, index, value):
        self.Class.insert(index, value)

    def replace_Class_at(self, index, value):
        self.Class[index] = value

    ClassProp = property(get_Class, set_Class)

    def get_Subclass(self):
        return self.Subclass

    def set_Subclass(self, Subclass):
        self.Subclass = Subclass

    def add_Subclass(self, value):
        self.Subclass.append(value)

    def insert_Subclass_at(self, index, value):
        self.Subclass.insert(index, value)

    def replace_Subclass_at(self, index, value):
        self.Subclass[index] = value

    SubclassProp = property(get_Subclass, set_Subclass)

    def get_Specification(self):
        return self.Specification

    def set_Specification(self, Specification):
        self.Specification = Specification

    def add_Specification(self, value):
        self.Specification.append(value)

    def insert_Specification_at(self, index, value):
        self.Specification.insert(index, value)

    def replace_Specification_at(self, index, value):
        self.Specification[index] = value

    SpecificationProp = property(get_Specification, set_Specification)

    def get_Source(self):
        return self.Source

    def set_Source(self, Source):
        self.Source = Source

    SourceProp = property(get_Source, set_Source)

    def get_Form(self):
        return self.Form

    def set_Form(self, Form):
        self.Form = Form

    FormProp = property(get_Form, set_Form)

    def get_ProcessingDetails(self):
        return self.ProcessingDetails

    def set_ProcessingDetails(self, ProcessingDetails):
        self.ProcessingDetails = ProcessingDetails

    def add_ProcessingDetails(self, value):
        self.ProcessingDetails.append(value)

    def insert_ProcessingDetails_at(self, index, value):
        self.ProcessingDetails.insert(index, value)

    def replace_ProcessingDetails_at(self, index, value):
        self.ProcessingDetails[index] = value

    ProcessingDetailsProp = property(get_ProcessingDetails, set_ProcessingDetails)

    def get_Characterization(self):
        return self.Characterization

    def set_Characterization(self, Characterization):
        self.Characterization = Characterization

    CharacterizationProp = property(get_Characterization, set_Characterization)

    def get_PropertyData(self, property=None):
        if property is not None:
            properties = []
            for property_data in self.get_PropertyData():
                if property_data.get_property() == property:
                    properties.append(property_data)
            return properties
        return self.PropertyData

    def set_PropertyData(self, PropertyData):
        self.PropertyData = PropertyData

    def add_PropertyData(self, value):
        self.PropertyData.append(value)

    def insert_PropertyData_at(self, index, value):
        self.PropertyData.insert(index, value)

    def replace_PropertyData_at(self, index, value):
        self.PropertyData[index] = value

    PropertyDataProp = property(get_PropertyData, set_PropertyData)

    def get_AssociationDetails(self):
        return self.AssociationDetails

    def set_AssociationDetails(self, AssociationDetails):
        self.AssociationDetails = AssociationDetails

    def add_AssociationDetails(self, value):
        self.AssociationDetails.append(value)

    def insert_AssociationDetails_at(self, index, value):
        self.AssociationDetails.insert(index, value)

    def replace_AssociationDetails_at(self, index, value):
        self.AssociationDetails[index] = value

    AssociationDetailsProp = property(get_AssociationDetails, set_AssociationDetails)

    def get_ComponentDetails(self, id=None):
        if id is not None:
            for component_details in self.get_ComponentDetails():
                if component_details.get_id() == id:
                    return component_details
            return None
        return self.ComponentDetails

    def set_ComponentDetails(self, ComponentDetails):
        self.ComponentDetails = ComponentDetails

    def add_ComponentDetails(self, value):
        self.ComponentDetails.append(value)

    def insert_ComponentDetails_at(self, index, value):
        self.ComponentDetails.insert(index, value)

    def replace_ComponentDetails_at(self, index, value):
        self.ComponentDetails[index] = value

    ComponentDetailsProp = property(get_ComponentDetails, set_ComponentDetails)

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def has__content(self):
        if (
            self.Name is not None
            or self.Class
            or self.Subclass
            or self.Specification
            or self.Source is not None
            or self.Form is not None
            or self.ProcessingDetails
            or self.Characterization is not None
            or self.PropertyData
            or self.AssociationDetails
            or self.ComponentDetails
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ComponentDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "ComponentDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix,
            name_="ComponentDetails",
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="ComponentDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="ComponentDetails",
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % quote_attrib(self.id))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ComponentDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        for Class_ in self.Class:
            namespaceprefix = (
                self.Class_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Class_nsprefix_)
                else ""
            )
            Class_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Class",
                pretty_print=pretty_print,
            )
        for Subclass_ in self.Subclass:
            namespaceprefix = (
                self.Subclass_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Subclass_nsprefix_)
                else ""
            )
            Subclass_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Subclass",
                pretty_print=pretty_print,
            )
        for Specification_ in self.Specification:
            namespaceprefix = (
                self.Specification_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Specification_nsprefix_)
                else ""
            )
            Specification_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Specification",
                pretty_print=pretty_print,
            )
        if self.Source is not None:
            namespaceprefix = (
                self.Source_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Source_nsprefix_)
                else ""
            )
            self.Source.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Source",
                pretty_print=pretty_print,
            )
        if self.Form is not None:
            namespaceprefix = (
                self.Form_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Form_nsprefix_)
                else ""
            )
            self.Form.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Form",
                pretty_print=pretty_print,
            )
        for ProcessingDetails_ in self.ProcessingDetails:
            namespaceprefix = (
                self.ProcessingDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ProcessingDetails_nsprefix_)
                else ""
            )
            ProcessingDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ProcessingDetails",
                pretty_print=pretty_print,
            )
        if self.Characterization is not None:
            namespaceprefix = (
                self.Characterization_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Characterization_nsprefix_)
                else ""
            )
            self.Characterization.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Characterization",
                pretty_print=pretty_print,
            )
        for PropertyData_ in self.PropertyData:
            namespaceprefix = (
                self.PropertyData_nsprefix_ + ":"
                if (UseCapturedNS_ and self.PropertyData_nsprefix_)
                else ""
            )
            PropertyData_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="PropertyData",
                pretty_print=pretty_print,
            )
        for AssociationDetails_ in self.AssociationDetails:
            namespaceprefix = (
                self.AssociationDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AssociationDetails_nsprefix_)
                else ""
            )
            AssociationDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="AssociationDetails",
                pretty_print=pretty_print,
            )
        for ComponentDetails_ in self.ComponentDetails:
            namespaceprefix = (
                self.ComponentDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ComponentDetails_nsprefix_)
                else ""
            )
            ComponentDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ComponentDetails",
                pretty_print=pretty_print,
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Class":
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_)
            self.Class.append(obj_)
            obj_.original_tagname_ = "Class"
        elif nodeName == "Subclass":
            obj_ = Class.factory(parent_object_=self)
            obj_.build(child_)
            self.Subclass.append(obj_)
            obj_.original_tagname_ = "Subclass"
        elif nodeName == "Specification":
            obj_ = Specification.factory(parent_object_=self)
            obj_.build(child_)
            self.Specification.append(obj_)
            obj_.original_tagname_ = "Specification"
        elif nodeName == "Source":
            obj_ = Source.factory(parent_object_=self)
            obj_.build(child_)
            self.Source = obj_
            obj_.original_tagname_ = "Source"
        elif nodeName == "Form":
            obj_ = Form.factory(parent_object_=self)
            obj_.build(child_)
            self.Form = obj_
            obj_.original_tagname_ = "Form"
        elif nodeName == "ProcessingDetails":
            obj_ = ProcessingDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.ProcessingDetails.append(obj_)
            obj_.original_tagname_ = "ProcessingDetails"
        elif nodeName == "Characterization":
            obj_ = Characterization.factory(parent_object_=self)
            obj_.build(child_)
            self.Characterization = obj_
            obj_.original_tagname_ = "Characterization"
        elif nodeName == "PropertyData":
            obj_ = PropertyData.factory(parent_object_=self)
            obj_.build(child_)
            self.PropertyData.append(obj_)
            obj_.original_tagname_ = "PropertyData"
        elif nodeName == "AssociationDetails":
            obj_ = AssociationDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.AssociationDetails.append(obj_)
            obj_.original_tagname_ = "AssociationDetails"
        elif nodeName == "ComponentDetails":
            obj_ = ComponentDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.ComponentDetails.append(obj_)
            obj_.original_tagname_ = "ComponentDetails"


class Compound(GeneratedsSuper):
    """This element declares the content model for `Compound`, which contains the elemental description of a chemical compound and is composed the following elements.

    - `Element` contains the description of a chemical element and must occur one or more times within the `Compound` element. For additional information, see the documentation for the `Element` element.
    - Concentration contains the concentration of the compound and may occur once or not at all within the `Compound` element. For additional information, see the documentation for the `Concentration` element.
    - `Notes` contains any additional information concerning the compound and may occur once or not at all within the `Compound` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Element: Element = None,
        Concentration: Concentration = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        if Element is None:
            self.Element = []
        else:
            self.Element = Element
        self.Element_nsprefix_ = None
        self.Concentration = Concentration
        self.Concentration_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Compound(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Element(self):
        return self.Element

    def set_Element(self, Element):
        self.Element = Element

    def add_Element(self, value):
        self.Element.append(value)

    def insert_Element_at(self, index, value):
        self.Element.insert(index, value)

    def replace_Element_at(self, index, value):
        self.Element[index] = value

    ElementProp = property(get_Element, set_Element)

    def get_Concentration(self):
        return self.Concentration

    def set_Concentration(self, Concentration):
        self.Concentration = Concentration

    ConcentrationProp = property(get_Concentration, set_Concentration)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if self.Element or self.Concentration is not None or self.Notes is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Compound",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Compound":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Compound",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Compound",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        for Element_ in self.Element:
            namespaceprefix = (
                self.Element_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Element_nsprefix_)
                else ""
            )
            Element_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Element",
                pretty_print=pretty_print,
            )
        if self.Concentration is not None:
            namespaceprefix = (
                self.Concentration_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Concentration_nsprefix_)
                else ""
            )
            self.Concentration.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Concentration",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Element":
            obj_ = Element.factory(parent_object_=self)
            obj_.build(child_)
            self.Element.append(obj_)
            obj_.original_tagname_ = "Element"
        elif nodeName == "Concentration":
            obj_ = Concentration.factory(parent_object_=self)
            obj_.build(child_)
            self.Concentration = obj_
            obj_.original_tagname_ = "Concentration"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class Concentration(GeneratedsSuper):
    """This element declares the content model for `Concentration` and is composed of the following elements.

    - `Value` contains the value of the concentration and has one required attribute, `format`, for indicating the format of the value.  `Value` must occur once and only once within the `Concentration` element.
    - `Units` contains the units for the value of the concentration and must occur once and only once within the `Concentration` element. For additional information, see the documentation for the `Units` element.
    - `Qualifier` contains any qualifier pertinent to the value of the concentration (e.g. "min," "max," etc.) and may occur once or not at all within the `Concentration` element.
    - `Uncertainty` contains the measurement uncertainty(ies) of the data in Data and may occur zero or more times within the `Concentration` element. For additional information, see the documentation for the `Uncertainty` type.
    - `Notes` contains any additional information concerning the concentration and may occur once or not at all within the `Concentration` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Value: Value = None,
        Units: Units = None,
        Qualifier: str = None,
        Uncertainty: Uncertainty = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Value = Value
        self.Value_nsprefix_ = None
        self.Units = Units
        self.Units_nsprefix_ = None
        if Qualifier is None:
            self.Qualifier = []
        else:
            self.Qualifier = Qualifier
        self.Qualifier_nsprefix_ = None
        if Uncertainty is None:
            self.Uncertainty = []
        else:
            self.Uncertainty = Uncertainty
        self.Uncertainty_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Concentration(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Value(self):
        return self.Value

    def set_Value(self, Value):
        self.Value = Value

    ValueProp = property(get_Value, set_Value)

    def get_Units(self):
        return self.Units

    def set_Units(self, Units):
        self.Units = Units

    UnitsProp = property(get_Units, set_Units)

    def get_Qualifier(self):
        return self.Qualifier

    def set_Qualifier(self, Qualifier):
        self.Qualifier = Qualifier

    def add_Qualifier(self, value):
        self.Qualifier.append(value)

    def insert_Qualifier_at(self, index, value):
        self.Qualifier.insert(index, value)

    def replace_Qualifier_at(self, index, value):
        self.Qualifier[index] = value

    QualifierProp = property(get_Qualifier, set_Qualifier)

    def get_Uncertainty(self):
        return self.Uncertainty

    def set_Uncertainty(self, Uncertainty):
        self.Uncertainty = Uncertainty

    def add_Uncertainty(self, value):
        self.Uncertainty.append(value)

    def insert_Uncertainty_at(self, index, value):
        self.Uncertainty.insert(index, value)

    def replace_Uncertainty_at(self, index, value):
        self.Uncertainty[index] = value

    UncertaintyProp = property(get_Uncertainty, set_Uncertainty)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Value is not None
            or self.Units is not None
            or self.Qualifier
            or self.Uncertainty
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Concentration",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Concentration":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Concentration",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Concentration",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Value is not None:
            namespaceprefix = (
                self.Value_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Value_nsprefix_)
                else ""
            )
            self.Value.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Value",
                pretty_print=pretty_print,
            )
        if self.Units is not None:
            namespaceprefix = (
                self.Units_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Units_nsprefix_)
                else ""
            )
            self.Units.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Units",
                pretty_print=pretty_print,
            )
        for Qualifier_ in self.Qualifier:
            namespaceprefix = (
                self.Qualifier_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Qualifier_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sQualifier>%s</%sQualifier>%s"
                % (
                    namespaceprefix,
                    quote_xml(Qualifier_),
                    namespaceprefix,
                    eol,
                )
            )
        for Uncertainty_ in self.Uncertainty:
            namespaceprefix = (
                self.Uncertainty_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Uncertainty_nsprefix_)
                else ""
            )
            Uncertainty_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Uncertainty",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Value":
            obj_ = Value.factory(parent_object_=self)
            obj_.build(child_)
            self.Value = obj_
            obj_.original_tagname_ = "Value"
        elif nodeName == "Units":
            obj_ = Units.factory(parent_object_=self)
            obj_.build(child_)
            self.Units = obj_
            obj_.original_tagname_ = "Units"
        elif nodeName == "Qualifier":
            value_ = child_.text

            self.Qualifier.append(value_)
            self.Qualifier_nsprefix_ = child_.prefix
        elif nodeName == "Uncertainty":
            obj_ = Uncertainty.factory(parent_object_=self)
            obj_.build(child_)
            self.Uncertainty.append(obj_)
            obj_.original_tagname_ = "Uncertainty"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class DimensionalDetails(GeneratedsSuper):
    """This element declares the content model for `DimensionalDetails`, which contains a description of a dimensional characteristic (e.g. grain size, porosity, precipitate size and distribution, etc.) of the bulk material or component and is composed of the following elements.

    - `Name` contains the name of the characteristic and has one optional attribute, `authority`, for identifying an authoritative source of dimensional characteristic names. `Name` must occur once and only once within the `DimensionalDetails` element.
    - `Value` contains the value of the dimensional characteristic and has one required attribute, format, for indicating the format of the value.  `Value` must occur once and only once within the `DimensionalDetails` element.
    - `Units` contains the units for the value of the dimensional characteristic and must occur once and only once within the `DimensionalDetails` element. For additional information, see the documentation for the `Units` type.
    - `Qualifier` contains any qualifier pertinent to the value of the dimensional characteristic (e.g. "min," "max," etc.) and may occur once or not at all within the `DimensionalDetails` element.
    - `Uncertainty` contains the measurement uncertainty(ies) of the data in Data and may occur zero or more times within the `DimensionalDetails` element. For additional information, see the documentation for the `Uncertainty` type.
    - `Notes` contains any additional information concerning the dimensional characteristic and may occur once or not at all within the `DimensionalDetails` element.

    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Name: Name = None,
        Value: Value = None,
        Units: Units = None,
        Qualifier: str = None,
        Uncertainty: Uncertainty = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Value = Value
        self.Value_nsprefix_ = None
        self.Units = Units
        self.Units_nsprefix_ = None
        self.Qualifier = Qualifier
        self.Qualifier_nsprefix_ = None
        if Uncertainty is None:
            self.Uncertainty = []
        else:
            self.Uncertainty = Uncertainty
        self.Uncertainty_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return DimensionalDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Value(self):
        return self.Value

    def set_Value(self, Value):
        self.Value = Value

    ValueProp = property(get_Value, set_Value)

    def get_Units(self):
        return self.Units

    def set_Units(self, Units):
        self.Units = Units

    UnitsProp = property(get_Units, set_Units)

    def get_Qualifier(self):
        return self.Qualifier

    def set_Qualifier(self, Qualifier):
        self.Qualifier = Qualifier

    QualifierProp = property(get_Qualifier, set_Qualifier)

    def get_Uncertainty(self):
        return self.Uncertainty

    def set_Uncertainty(self, Uncertainty):
        self.Uncertainty = Uncertainty

    def add_Uncertainty(self, value):
        self.Uncertainty.append(value)

    def insert_Uncertainty_at(self, index, value):
        self.Uncertainty.insert(index, value)

    def replace_Uncertainty_at(self, index, value):
        self.Uncertainty[index] = value

    UncertaintyProp = property(get_Uncertainty, set_Uncertainty)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Name is not None
            or self.Value is not None
            or self.Units is not None
            or self.Qualifier is not None
            or self.Uncertainty
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="DimensionalDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "DimensionalDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="DimensionalDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="DimensionalDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Value is not None:
            namespaceprefix = (
                self.Value_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Value_nsprefix_)
                else ""
            )
            self.Value.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Value",
                pretty_print=pretty_print,
            )
        if self.Units is not None:
            namespaceprefix = (
                self.Units_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Units_nsprefix_)
                else ""
            )
            self.Units.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Units",
                pretty_print=pretty_print,
            )
        if self.Qualifier is not None:
            namespaceprefix = (
                self.Qualifier_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Qualifier_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sQualifier>%s</%sQualifier>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Qualifier),
                    namespaceprefix,
                    eol,
                )
            )
        for Uncertainty_ in self.Uncertainty:
            namespaceprefix = (
                self.Uncertainty_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Uncertainty_nsprefix_)
                else ""
            )
            Uncertainty_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Uncertainty",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Value":
            obj_ = Value.factory(parent_object_=self)
            obj_.build(child_)
            self.Value = obj_
            obj_.original_tagname_ = "Value"
        elif nodeName == "Units":
            obj_ = Units.factory(parent_object_=self)
            obj_.build(child_)
            self.Units = obj_
            obj_.original_tagname_ = "Units"
        elif nodeName == "Qualifier":
            value_ = child_.text

            self.Qualifier = value_
            self.Qualifier_nsprefix_ = child_.prefix
        elif nodeName == "Uncertainty":
            obj_ = Uncertainty.factory(parent_object_=self)
            obj_.build(child_)
            self.Uncertainty.append(obj_)
            obj_.original_tagname_ = "Uncertainty"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class Element(GeneratedsSuper):
    """This element declares the content model for `Element` and is composed of the following elements.

    - `Symbol` contains the symbol for the chemical element, which is one among those enumerated by the `ChemicalElementSymbol` datatype. `Symbol` has one optional attribute, `subscript`, for indicating the subscript (formula units) of the chemical element. `Symbol` must occur once and only once within the `Element` element. For additional information, see the documentation for the `ChemicalElementSymbol` datatype.
    - `Concentration` contains the concentration of the element and may occur once or not at all within the `Element` element. For additional information, see the documentation for the `Concentration` element.
    - `Notes` contains any additional information concerning the element and may occur once or not at all within the `Element` element.

    `Symbol`:
    - This element declares the content model for `Symbol`, which contains the symbol for the chemical element.
    - The entry for `Symbol` is selected from among the strings enumerated by the `ChemicalElementSymbol` datatype.
    - `Symbol` has one optional attribute, `subscript`, for indicating the subscript (formula units) of the chemical element.

    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Symbol: SymbolType = None,
        Concentration: Concentration = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Symbol = Symbol
        self.Symbol_nsprefix_ = None
        self.Concentration = Concentration
        self.Concentration_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Element(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Symbol(self):
        return self.Symbol

    def set_Symbol(self, Symbol):
        self.Symbol = Symbol

    SymbolProp = property(get_Symbol, set_Symbol)

    def get_Concentration(self):
        return self.Concentration

    def set_Concentration(self, Concentration):
        self.Concentration = Concentration

    ConcentrationProp = property(get_Concentration, set_Concentration)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Symbol is not None
            or self.Concentration is not None
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Element",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Element":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Element",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Element",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Symbol is not None:
            namespaceprefix = (
                self.Symbol_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Symbol_nsprefix_)
                else ""
            )
            self.Symbol.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Symbol",
                pretty_print=pretty_print,
            )
        if self.Concentration is not None:
            namespaceprefix = (
                self.Concentration_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Concentration_nsprefix_)
                else ""
            )
            self.Concentration.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Concentration",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Symbol":
            obj_ = SymbolType.factory(parent_object_=self)
            obj_.build(child_)
            self.Symbol = obj_
            obj_.original_tagname_ = "Symbol"
        elif nodeName == "Concentration":
            obj_ = Concentration.factory(parent_object_=self)
            obj_.build(child_)
            self.Concentration = obj_
            obj_.original_tagname_ = "Concentration"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class Form(GeneratedsSuper):
    """This element declares the content model for `Form`, which contains a description of the form of the bulk material or component.

    It also contains an element to describe the geometry of the the form and an element for any notes.  For additional information, see the documentation for the `Geometry` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Description: Name = None,
        Geometry: Geometry = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Description = Description
        self.Description_nsprefix_ = None
        self.Geometry = Geometry
        self.Geometry_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Form(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Description(self):
        return self.Description

    def set_Description(self, Description):
        self.Description = Description

    DescriptionProp = property(get_Description, set_Description)

    def get_Geometry(self):
        return self.Geometry

    def set_Geometry(self, Geometry):
        self.Geometry = Geometry

    GeometryProp = property(get_Geometry, set_Geometry)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Description is not None
            or self.Geometry is not None
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Form",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Form":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Form",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Form",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Description is not None:
            namespaceprefix = (
                self.Description_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Description_nsprefix_)
                else ""
            )
            self.Description.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Description",
                pretty_print=pretty_print,
            )
        if self.Geometry is not None:
            namespaceprefix = (
                self.Geometry_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Geometry_nsprefix_)
                else ""
            )
            self.Geometry.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Geometry",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Description":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Description = obj_
            obj_.original_tagname_ = "Description"
        elif nodeName == "Geometry":
            obj_ = Geometry.factory(parent_object_=self)
            obj_.build(child_)
            self.Geometry = obj_
            obj_.original_tagname_ = "Geometry"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class Geometry(GeneratedsSuper):
    """This element declares the content model for `Geometry`, which contains a description of the geometry of the bulk material, component or specimen and is composed of the following elements.

    - `Shape` is a string describing the shape of the bulk material or component and must occur once and only once within the `Geometry` element.
    - `Dimensions` is a string describing the dimensions of the bulk material or component and may occur once or not at all within the `Geometry` element.
    - `Orientation`  is a string describing the orientation of the bulk material or component and may occur once or not at all within the `Geometry` element.
    - `Notes` contains any additional information concerning the geometry and may occur once or not at all within the `Geometry` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Shape: str = None,
        Dimensions: str = None,
        Orientation: str = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Shape = Shape
        self.Shape_nsprefix_ = None
        self.Dimensions = Dimensions
        self.Dimensions_nsprefix_ = None
        self.Orientation = Orientation
        self.Orientation_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Geometry(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Shape(self):
        return self.Shape

    def set_Shape(self, Shape):
        self.Shape = Shape

    ShapeProp = property(get_Shape, set_Shape)

    def get_Dimensions(self):
        return self.Dimensions

    def set_Dimensions(self, Dimensions):
        self.Dimensions = Dimensions

    DimensionsProp = property(get_Dimensions, set_Dimensions)

    def get_Orientation(self):
        return self.Orientation

    def set_Orientation(self, Orientation):
        self.Orientation = Orientation

    OrientationProp = property(get_Orientation, set_Orientation)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Shape is not None
            or self.Dimensions is not None
            or self.Orientation is not None
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Geometry",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Geometry":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Geometry",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Geometry",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Shape is not None:
            namespaceprefix = (
                self.Shape_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Shape_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sShape>%s</%sShape>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Shape),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Dimensions is not None:
            namespaceprefix = (
                self.Dimensions_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Dimensions_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDimensions>%s</%sDimensions>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Dimensions),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Orientation is not None:
            namespaceprefix = (
                self.Orientation_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Orientation_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sOrientation>%s</%sOrientation>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Orientation),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Shape":
            value_ = child_.text
            self.Shape = value_
            self.Shape_nsprefix_ = child_.prefix
        elif nodeName == "Dimensions":
            value_ = child_.text
            self.Dimensions = value_
            self.Dimensions_nsprefix_ = child_.prefix
        elif nodeName == "Orientation":
            value_ = child_.text
            self.Orientation = value_
            self.Orientation_nsprefix_ = child_.prefix
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class Glossary(GeneratedsSuper):
    """This element declares the content model for `Glossary`, which contains descriptions of material and property terms used in the document. `Glossary` must contain one or more `GlossaryTerm` elements."""

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Term: GlossaryTerm = None, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        if Term is None:
            self.Term = []
        else:
            self.Term = Term
        self.Term_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Glossary(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Term(self):
        return self.Term

    def set_Term(self, Term):
        self.Term = Term

    def add_Term(self, value):
        self.Term.append(value)

    def insert_Term_at(self, index, value):
        self.Term.insert(index, value)

    def replace_Term_at(self, index, value):
        self.Term[index] = value

    TermProp = property(get_Term, set_Term)

    def has__content(self):
        if self.Term:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Glossary",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Glossary":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Glossary",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Glossary",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        for Term_ in self.Term:
            namespaceprefix = (
                self.Term_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Term_nsprefix_)
                else ""
            )
            Term_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Term",
                pretty_print=pretty_print,
            )

    def build(self, node):

        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Term":
            obj_ = GlossaryTerm.factory(parent_object_=self)
            obj_.build(child_)
            self.Term.append(obj_)
            obj_.original_tagname_ = "Term"


class GlossaryTerm(GeneratedsSuper):
    """This element declares the content model for `GlossaryTerm` which is composed of the following elements.

    - `Name` contains the term's name and has one optional attribute, authority, for identifying an authoritative source of terms. Name must occur once and only once within the `GlossaryTerm` element.
    - `Definition` contains the term's definition and must occur once and only once within the `GlossaryTerm` element.
    - `Abbreviation` contains the term's abbreviations and may occur zero or more times within the `GlossaryTerm` element.
    - `Synonym` contains the term's synonyms and may occur zero or more times within the `GlossaryTerm` element.
    - `Notes` contains any additional information concerning the term and may occur once or not at all within the `GlossaryTerm` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Name: Name = None,
        Definition: str = None,
        Abbreviation: str = None,
        Synonym: str = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Definition = Definition
        self.Definition_nsprefix_ = None
        if Abbreviation is None:
            self.Abbreviation = []
        else:
            self.Abbreviation = Abbreviation
        self.Abbreviation_nsprefix_ = None
        if Synonym is None:
            self.Synonym = []
        else:
            self.Synonym = Synonym
        self.Synonym_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return GlossaryTerm(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Definition(self):
        return self.Definition

    def set_Definition(self, Definition):
        self.Definition = Definition

    DefinitionProp = property(get_Definition, set_Definition)

    def get_Abbreviation(self):
        return self.Abbreviation

    def set_Abbreviation(self, Abbreviation):
        self.Abbreviation = Abbreviation

    def add_Abbreviation(self, value):
        self.Abbreviation.append(value)

    def insert_Abbreviation_at(self, index, value):
        self.Abbreviation.insert(index, value)

    def replace_Abbreviation_at(self, index, value):
        self.Abbreviation[index] = value

    AbbreviationProp = property(get_Abbreviation, set_Abbreviation)

    def get_Synonym(self):
        return self.Synonym

    def set_Synonym(self, Synonym):
        self.Synonym = Synonym

    def add_Synonym(self, value):
        self.Synonym.append(value)

    def insert_Synonym_at(self, index, value):
        self.Synonym.insert(index, value)

    def replace_Synonym_at(self, index, value):
        self.Synonym[index] = value

    SynonymProp = property(get_Synonym, set_Synonym)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Name is not None
            or self.Definition is not None
            or self.Abbreviation
            or self.Synonym
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="GlossaryTerm",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "GlossaryTerm":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="GlossaryTerm",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="GlossaryTerm",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Definition is not None:
            namespaceprefix = (
                self.Definition_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Definition_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sDefinition>%s</%sDefinition>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Definition),
                    namespaceprefix,
                    eol,
                )
            )
        for Abbreviation_ in self.Abbreviation:
            namespaceprefix = (
                self.Abbreviation_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Abbreviation_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sAbbreviation>%s</%sAbbreviation>%s"
                % (
                    namespaceprefix,
                    quote_xml(Abbreviation_),
                    namespaceprefix,
                    eol,
                )
            )
        for Synonym_ in self.Synonym:
            namespaceprefix = (
                self.Synonym_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Synonym_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sSynonym>%s</%sSynonym>%s"
                % (
                    namespaceprefix,
                    quote_xml(Synonym_),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Definition":
            value_ = child_.text
            self.Definition = value_
            self.Definition_nsprefix_ = child_.prefix
        elif nodeName == "Abbreviation":
            value_ = child_.text
            self.Abbreviation.append(value_)
            self.Abbreviation_nsprefix_ = child_.prefix
        elif nodeName == "Synonym":
            value_ = child_.text
            self.Synonym.append(value_)
            self.Synonym_nsprefix_ = child_.prefix
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class Graphs(GeneratedsSuper):
    """This element declares the content model for `Graphs`, which must contain one or more `Graph` elements.

    `Graph` uses the W3C's Scalable Vector Graphics markup language (SVG) for describing two dimensional graphics and allows for three types of graphical objects: vector graphics shapes, images, and text.

    `Graph` must occur one or more times within the `Graphs` element. For more information concerning SVG, see the documentation at http://www.w3.org/TR/SVG/.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, Graph: GraphType = None, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        if Graph is None:
            self.Graph = []
        else:
            self.Graph = Graph
        self.Graph_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Graphs(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Graph(self):
        return self.Graph

    def set_Graph(self, Graph):
        self.Graph = Graph

    def add_Graph(self, value):
        self.Graph.append(value)

    def insert_Graph_at(self, index, value):
        self.Graph.insert(index, value)

    def replace_Graph_at(self, index, value):
        self.Graph[index] = value

    GraphProp = property(get_Graph, set_Graph)

    def has__content(self):
        if self.Graph:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Graphs",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Graphs":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Graphs",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Graphs",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        for Graph_ in self.Graph:
            namespaceprefix = (
                self.Graph_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Graph_nsprefix_)
                else ""
            )
            Graph_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Graph",
                pretty_print=pretty_print,
            )

    def build(self, node):

        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Graph":
            obj_ = GraphType.factory(parent_object_=self)
            obj_.build(child_)
            self.Graph.append(obj_)
            obj_.original_tagname_ = "Graph"


class Material(GeneratedsSuper):
    """This element declares the content model for `Material`, which contains materials data. `Material` has three optional attributes.

    1. The first attribute, `id`, may be used as an identification specifier for the material, which is especially useful for complex systems such as composite laminates.
    2. The second attribute, `layers`, may be used to indicate the number of layers in complex systems such as composite laminates.
    3. The third attribute, `local_frame_of_reference`, may be used as an identification specifier for the local material orientation relative to the global frame of reference, which is especially useful for complex systems such as anisotropic materials.

    Material is composed of the following elements.

    - BulkDetails contains a description of the bulk material and must occur once and only once within the Material element. For additional information, see the documentation for the BulkDetails element.
    - ComponentDetails contains a description of a component within the bulk material and may occur zero or more times within the Material element. ComponentDetails may be used to describe complex materials systems such as welds (e.g. the base metal, the heat affected zone, and the weld metal) or composites (e.g. the whiskers, fibers, and matrix of a fiber-reinforced composite material). For additional information, see the documentation for the ComponentDetails element.
    - Graphs contains descriptions of two dimensional graphics and may occur once or not at all within the Material element. For additional information, see the documentation for the Graphs element.
    - Glossary contains descriptions of the material and property terms used in the document and may occur once or not at all within the Material element. For additional information, see the documentation for the Glossary element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        id: str = None,
        layers: int = None,
        local_frame_of_reference: str = None,
        BulkDetails: BulkDetails = None,
        ComponentDetails: BulkDetails = None,
        Graphs: Graphs = None,
        Glossary: Glossary = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.layers = _cast(int, layers)
        self.layers_nsprefix_ = None
        self.local_frame_of_reference = _cast(None, local_frame_of_reference)
        self.local_frame_of_reference_nsprefix_ = None
        self.BulkDetails = BulkDetails
        self.BulkDetails_nsprefix_ = None
        if ComponentDetails is None:
            self.ComponentDetails = []
        else:
            self.ComponentDetails = ComponentDetails
        self.ComponentDetails_nsprefix_ = None
        self.Graphs = Graphs
        self.Graphs_nsprefix_ = None
        self.Glossary = Glossary
        self.Glossary_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Material(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_BulkDetails(self):
        return self.BulkDetails

    def set_BulkDetails(self, BulkDetails):
        self.BulkDetails = BulkDetails

    BulkDetailsProp = property(get_BulkDetails, set_BulkDetails)

    def get_ComponentDetails(self, id=None):
        if id is not None:
            for component_details in self.get_ComponentDetails():
                if component_details.get_id() == id:
                    return component_details
            return None
        return self.ComponentDetails

    def set_ComponentDetails(self, ComponentDetails):
        self.ComponentDetails = ComponentDetails

    def add_ComponentDetails(self, value):
        self.ComponentDetails.append(value)

    def insert_ComponentDetails_at(self, index, value):
        self.ComponentDetails.insert(index, value)

    def replace_ComponentDetails_at(self, index, value):
        self.ComponentDetails[index] = value

    ComponentDetailsProp = property(get_ComponentDetails, set_ComponentDetails)

    def get_Graphs(self):
        return self.Graphs

    def set_Graphs(self, Graphs):
        self.Graphs = Graphs

    GraphsProp = property(get_Graphs, set_Graphs)

    def get_Glossary(self):
        return self.Glossary

    def set_Glossary(self, Glossary):
        self.Glossary = Glossary

    GlossaryProp = property(get_Glossary, set_Glossary)

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def get_layers(self):
        return self.layers

    def set_layers(self, layers):
        self.layers = layers

    layersProp = property(get_layers, set_layers)

    def get_local_frame_of_reference(self):
        return self.local_frame_of_reference

    def set_local_frame_of_reference(self, local_frame_of_reference):
        self.local_frame_of_reference = local_frame_of_reference

    local_frame_of_referenceProp = property(
        get_local_frame_of_reference, set_local_frame_of_reference
    )

    def has__content(self):
        if (
            self.BulkDetails is not None
            or self.ComponentDetails
            or self.Graphs is not None
            or self.Glossary is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Material",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Material":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="Material"
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Material",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix="", name_="Material"
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % (quote_attrib(self.id)))
        if self.layers is not None and "layers" not in already_processed:
            already_processed.add("layers")
            outfile.write(' layers="%s"' % int(self.layers))
        if (
            self.local_frame_of_reference is not None
            and "local_frame_of_reference" not in already_processed
        ):
            already_processed.add("local_frame_of_reference")
            outfile.write(
                " local_frame_of_reference=%s"
                % (quote_attrib(self.local_frame_of_reference),)
            )

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Material",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.BulkDetails is not None:
            namespaceprefix = (
                self.BulkDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.BulkDetails_nsprefix_)
                else ""
            )
            self.BulkDetails.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="BulkDetails",
                pretty_print=pretty_print,
            )
        for ComponentDetails_ in self.ComponentDetails:
            namespaceprefix = (
                self.ComponentDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ComponentDetails_nsprefix_)
                else ""
            )
            ComponentDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ComponentDetails",
                pretty_print=pretty_print,
            )
        if self.Graphs is not None:
            namespaceprefix = (
                self.Graphs_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Graphs_nsprefix_)
                else ""
            )
            self.Graphs.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Graphs",
                pretty_print=pretty_print,
            )
        if self.Glossary is not None:
            namespaceprefix = (
                self.Glossary_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Glossary_nsprefix_)
                else ""
            )
            self.Glossary.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Glossary",
                pretty_print=pretty_print,
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value
        value = find_attr_value_("layers", node)
        if value is not None and "layers" not in already_processed:
            already_processed.add("layers")
            self.layers = int(value)
        value = find_attr_value_("local_frame_of_reference", node)
        if value is not None and "local_frame_of_reference" not in already_processed:
            already_processed.add("local_frame_of_reference")
            self.local_frame_of_reference = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "BulkDetails":
            obj_ = BulkDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.BulkDetails = obj_
            obj_.original_tagname_ = "BulkDetails"
        elif nodeName == "ComponentDetails":
            obj_ = ComponentDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.ComponentDetails.append(obj_)
            obj_.original_tagname_ = "ComponentDetails"
        elif nodeName == "Graphs":
            obj_ = Graphs.factory(parent_object_=self)
            obj_.build(child_)
            self.Graphs = obj_
            obj_.original_tagname_ = "Graphs"
        elif nodeName == "Glossary":
            obj_ = Glossary.factory(parent_object_=self)
            obj_.build(child_)
            self.Glossary = obj_
            obj_.original_tagname_ = "Glossary"


class Metadata(GeneratedsSuper):
    """This element declares the content model for `Metadata`, which contains descriptions of authorities, data sources, measurement techniques, parameters, properties, material and component sources, specimens, and test conditions. `Metadata` is composed of the following elements.

    - `AuthorityDetails` contains a description of authorities referenced from the `Specification` and `Name` elements and may occur zero or more times within the `Metadata` element. For additional information, see the documentation for the `AuthorityDetails` element.
    - `DataSourceDetails` contains a description of a data source referenced using the `PropertyData` element and may occur zero or more times within the `Metadata` element. For additional information, see the documentation for the `DataSourceDetails` element.
    - `MeasurementTechniqueDetails` contains a description of a measurement technique referenced using the `PropertyData` element and may occur zero or more times within the `Metadata` element. For additional information, see the documentation for the `MeasurementTechniqueDetails` element.
    - `ParameterDetails` contains a description of a parameter referenced using the `PropertyData` element and may occur zero or more times within the `Metadata` element. For additional information, see the documentation for the `ParameterDetails` element.
    - `PropertyDetails` contains a description of a property for which materials data are encoded using the `PropertyData` element and may occur zero or more times within the `Metadata` element. For additional information, see the documentation for the Prope`r`tyDetails element.
    - `SourceDetails` contains a description of the source of a material or component referenced using the Source element and may occur zero or more times within the `Metadata` element. For additional information, see the documentation for the `SourceDetails` element.
    - `SpecimenDetails` contains a description of a specimen referenced using the `PropertyData` element and may occur zero or more times within the `Metadata` element. For additional information, see the documentation for the `SpecimenDetails` element.
    - `TestCondtionDetails` contains a description of the test condtion(s) referenced using the `PropertyData` element and may occur zero or more times within the `Metadata` element. For additional information, see the documentation for the `TestCondtionDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        AuthorityDetails: AuthorityDetails = None,
        DataSourceDetails: DataSourceDetails = None,
        MeasurementTechniqueDetails: MeasurementTechniqueDetails = None,
        ParameterDetails: ParameterDetails = None,
        PropertyDetails: PropertyDetails = None,
        SourceDetails: SourceDetails = None,
        SpecimenDetails: SpecimenDetails = None,
        TestConditionDetails: TestConditionDetails = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        if AuthorityDetails is None:
            self.AuthorityDetails = []
        else:
            self.AuthorityDetails = AuthorityDetails
        self.AuthorityDetails_nsprefix_ = None
        if DataSourceDetails is None:
            self.DataSourceDetails = []
        else:
            self.DataSourceDetails = DataSourceDetails
        self.DataSourceDetails_nsprefix_ = None
        if MeasurementTechniqueDetails is None:
            self.MeasurementTechniqueDetails = []
        else:
            self.MeasurementTechniqueDetails = MeasurementTechniqueDetails
        self.MeasurementTechniqueDetails_nsprefix_ = None
        if ParameterDetails is None:
            self.ParameterDetails = []
        else:
            self.ParameterDetails = ParameterDetails
        self.ParameterDetails_nsprefix_ = None
        if PropertyDetails is None:
            self.PropertyDetails = []
        else:
            self.PropertyDetails = PropertyDetails
        self.PropertyDetails_nsprefix_ = None
        if SourceDetails is None:
            self.SourceDetails = []
        else:
            self.SourceDetails = SourceDetails
        self.SourceDetails_nsprefix_ = None
        if SpecimenDetails is None:
            self.SpecimenDetails = []
        else:
            self.SpecimenDetails = SpecimenDetails
        self.SpecimenDetails_nsprefix_ = None
        if TestConditionDetails is None:
            self.TestConditionDetails = []
        else:
            self.TestConditionDetails = TestConditionDetails
        self.TestConditionDetails_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Metadata(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_AuthorityDetails(self, id=None):
        if id is not None:
            for authority_details in self.get_AuthorityDetails():
                if authority_details.get_id() == id:
                    return authority_details
            return None
        return self.AuthorityDetails

    def set_AuthorityDetails(self, AuthorityDetails):
        self.AuthorityDetails = AuthorityDetails

    def add_AuthorityDetails(self, value):
        self.AuthorityDetails.append(value)

    def insert_AuthorityDetails_at(self, index, value):
        self.AuthorityDetails.insert(index, value)

    def replace_AuthorityDetails_at(self, index, value):
        self.AuthorityDetails[index] = value

    AuthorityDetailsProp = property(get_AuthorityDetails, set_AuthorityDetails)

    def get_DataSourceDetails(self, id=None):
        if id is not None:
            for data_source_details in self.get_DataSourceDetails():
                if data_source_details.get_id() == id:
                    return data_source_details
            return None
        return self.DataSourceDetails

    def set_DataSourceDetails(self, DataSourceDetails):
        self.DataSourceDetails = DataSourceDetails

    def add_DataSourceDetails(self, value):
        self.DataSourceDetails.append(value)

    def insert_DataSourceDetails_at(self, index, value):
        self.DataSourceDetails.insert(index, value)

    def replace_DataSourceDetails_at(self, index, value):
        self.DataSourceDetails[index] = value

    DataSourceDetailsProp = property(get_DataSourceDetails, set_DataSourceDetails)

    def get_MeasurementTechniqueDetails(self, id=None):
        if id is not None:
            for measurement_technique_details in self.get_MeasurementTechniqueDetails():
                if measurement_technique_details.get_id() == id:
                    return measurement_technique_details
            return None
        return self.MeasurementTechniqueDetails

    def set_MeasurementTechniqueDetails(self, MeasurementTechniqueDetails):
        self.MeasurementTechniqueDetails = MeasurementTechniqueDetails

    def add_MeasurementTechniqueDetails(self, value):
        self.MeasurementTechniqueDetails.append(value)

    def insert_MeasurementTechniqueDetails_at(self, index, value):
        self.MeasurementTechniqueDetails.insert(index, value)

    def replace_MeasurementTechniqueDetails_at(self, index, value):
        self.MeasurementTechniqueDetails[index] = value

    MeasurementTechniqueDetailsProp = property(
        get_MeasurementTechniqueDetails, set_MeasurementTechniqueDetails
    )

    def get_ParameterDetails(self, id=None):
        if id is not None:
            for parameter_details in self.get_ParameterDetails():
                if parameter_details.get_id() == id:
                    return parameter_details
            return None
        return self.ParameterDetails

    def set_ParameterDetails(self, ParameterDetails):
        self.ParameterDetails = ParameterDetails

    def add_ParameterDetails(self, value):
        self.ParameterDetails.append(value)

    def insert_ParameterDetails_at(self, index, value):
        self.ParameterDetails.insert(index, value)

    def replace_ParameterDetails_at(self, index, value):
        self.ParameterDetails[index] = value

    ParameterDetailsProp = property(get_ParameterDetails, set_ParameterDetails)

    def get_PropertyDetails(self, id=None):
        if id is not None:
            for property_details in self.get_PropertyDetails():
                if property_details.get_id() == id:
                    return property_details
            return None
        return self.PropertyDetails

    def set_PropertyDetails(self, PropertyDetails):
        self.PropertyDetails = PropertyDetails

    def add_PropertyDetails(self, value):
        self.PropertyDetails.append(value)

    def insert_PropertyDetails_at(self, index, value):
        self.PropertyDetails.insert(index, value)

    def replace_PropertyDetails_at(self, index, value):
        self.PropertyDetails[index] = value

    PropertyDetailsProp = property(get_PropertyDetails, set_PropertyDetails)

    def get_SourceDetails(self, id=None):
        if id is not None:
            for source_details in self.get_SourceDetails():
                if source_details.get_id() == id:
                    return source_details
            return None
        return self.SourceDetails

    def set_SourceDetails(self, SourceDetails):
        self.SourceDetails = SourceDetails

    def add_SourceDetails(self, value):
        self.SourceDetails.append(value)

    def insert_SourceDetails_at(self, index, value):
        self.SourceDetails.insert(index, value)

    def replace_SourceDetails_at(self, index, value):
        self.SourceDetails[index] = value

    SourceDetailsProp = property(get_SourceDetails, set_SourceDetails)

    def get_SpecimenDetails(self, id=None):
        if id is not None:
            for specimen_details in self.get_SpecimenDetails():
                if specimen_details.get_id() == id:
                    return specimen_details
            return None
        return self.SpecimenDetails

    def set_SpecimenDetails(self, SpecimenDetails):
        self.SpecimenDetails = SpecimenDetails

    def add_SpecimenDetails(self, value):
        self.SpecimenDetails.append(value)

    def insert_SpecimenDetails_at(self, index, value):
        self.SpecimenDetails.insert(index, value)

    def replace_SpecimenDetails_at(self, index, value):
        self.SpecimenDetails[index] = value

    SpecimenDetailsProp = property(get_SpecimenDetails, set_SpecimenDetails)

    def get_TestConditionDetails(self, id=None):
        if id is not None:
            for test_condition_details in self.get_TestConditionDetails():
                if test_condition_details.get_id() == id:
                    return test_condition_details
            return None
        return self.TestConditionDetails

    def set_TestConditionDetails(self, TestConditionDetails):
        self.TestConditionDetails = TestConditionDetails

    def add_TestConditionDetails(self, value):
        self.TestConditionDetails.append(value)

    def insert_TestConditionDetails_at(self, index, value):
        self.TestConditionDetails.insert(index, value)

    def replace_TestConditionDetails_at(self, index, value):
        self.TestConditionDetails[index] = value

    TestConditionDetailsProp = property(
        get_TestConditionDetails, set_TestConditionDetails
    )

    def has__content(self):
        if (
            self.AuthorityDetails
            or self.DataSourceDetails
            or self.MeasurementTechniqueDetails
            or self.ParameterDetails
            or self.PropertyDetails
            or self.SourceDetails
            or self.SpecimenDetails
            or self.TestConditionDetails
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Metadata",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Metadata":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Metadata",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Metadata",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        for AuthorityDetails_ in self.AuthorityDetails:
            namespaceprefix = (
                self.AuthorityDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.AuthorityDetails_nsprefix_)
                else ""
            )
            AuthorityDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="AuthorityDetails",
                pretty_print=pretty_print,
            )
        for DataSourceDetails_ in self.DataSourceDetails:
            namespaceprefix = (
                self.DataSourceDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.DataSourceDetails_nsprefix_)
                else ""
            )
            DataSourceDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="DataSourceDetails",
                pretty_print=pretty_print,
            )
        for MeasurementTechniqueDetails_ in self.MeasurementTechniqueDetails:
            namespaceprefix = (
                self.MeasurementTechniqueDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.MeasurementTechniqueDetails_nsprefix_)
                else ""
            )
            MeasurementTechniqueDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="MeasurementTechniqueDetails",
                pretty_print=pretty_print,
            )
        for ParameterDetails_ in self.ParameterDetails:
            namespaceprefix = (
                self.ParameterDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ParameterDetails_nsprefix_)
                else ""
            )
            ParameterDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ParameterDetails",
                pretty_print=pretty_print,
            )
        for PropertyDetails_ in self.PropertyDetails:
            namespaceprefix = (
                self.PropertyDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.PropertyDetails_nsprefix_)
                else ""
            )
            PropertyDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="PropertyDetails",
                pretty_print=pretty_print,
            )
        for SourceDetails_ in self.SourceDetails:
            namespaceprefix = (
                self.SourceDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.SourceDetails_nsprefix_)
                else ""
            )
            SourceDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="SourceDetails",
                pretty_print=pretty_print,
            )
        for SpecimenDetails_ in self.SpecimenDetails:
            namespaceprefix = (
                self.SpecimenDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.SpecimenDetails_nsprefix_)
                else ""
            )
            SpecimenDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="SpecimenDetails",
                pretty_print=pretty_print,
            )
        for TestConditionDetails_ in self.TestConditionDetails:
            namespaceprefix = (
                self.TestConditionDetails_nsprefix_ + ":"
                if (UseCapturedNS_ and self.TestConditionDetails_nsprefix_)
                else ""
            )
            TestConditionDetails_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="TestConditionDetails",
                pretty_print=pretty_print,
            )

    def build(self, node):

        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "AuthorityDetails":
            obj_ = AuthorityDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.AuthorityDetails.append(obj_)
            obj_.original_tagname_ = "AuthorityDetails"
        elif nodeName == "DataSourceDetails":
            obj_ = DataSourceDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.DataSourceDetails.append(obj_)
            obj_.original_tagname_ = "DataSourceDetails"
        elif nodeName == "MeasurementTechniqueDetails":
            obj_ = MeasurementTechniqueDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.MeasurementTechniqueDetails.append(obj_)
            obj_.original_tagname_ = "MeasurementTechniqueDetails"
        elif nodeName == "ParameterDetails":
            obj_ = ParameterDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.ParameterDetails.append(obj_)
            obj_.original_tagname_ = "ParameterDetails"
        elif nodeName == "PropertyDetails":
            obj_ = PropertyDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.PropertyDetails.append(obj_)
            obj_.original_tagname_ = "PropertyDetails"
        elif nodeName == "SourceDetails":
            obj_ = SourceDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.SourceDetails.append(obj_)
            obj_.original_tagname_ = "SourceDetails"
        elif nodeName == "SpecimenDetails":
            obj_ = SpecimenDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.SpecimenDetails.append(obj_)
            obj_.original_tagname_ = "SpecimenDetails"
        elif nodeName == "TestConditionDetails":
            obj_ = TestConditionDetails.factory(parent_object_=self)
            obj_.build(child_)
            self.TestConditionDetails.append(obj_)
            obj_.original_tagname_ = "TestConditionDetails"


class Name(GeneratedsSuper):
    """This element declares the content model for `Name`, which contains a string representing a name and has one optional attribute, `authority`, for identifying an authoritative source of names in the context in which the `Name` element is used."""

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, authority: str = None, valueOf_=None, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs):

        return Name(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_authority(self):
        return self.authority

    def set_authority(self, authority):
        self.authority = authority

    authorityProp = property(get_authority, set_authority)

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def has__content(self):
        if 1 if type(self.valueOf_) in [int, float] else self.valueOf_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Name",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Name":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="Name"
        )
        outfile.write(">")

        outfile.write(quote_xml(self.valueOf_))
        outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix="", name_="Name"
    ):
        if self.authority is not None and "authority" not in already_processed:
            already_processed.add("authority")
            outfile.write(" authority=%s" % (quote_attrib(self.authority),))

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]

        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("authority", node)
        if value is not None and "authority" not in already_processed:
            already_processed.add("authority")
            self.authority = value


class ParameterValue(GeneratedsSuper):
    """This element declares the content model for `ParameterValue`, which contains the value of a parameter. `ParameterValue` has two required attributes.

    1. The first attribute, `parameter`, references an id attribute specified in a `ParameterDetails` element so that the descriptive details of the parameter are tied to the value.
    2. The second attribute, `format`, indicates the format of the value.  If used, "mixed" indicates that the not all of the parameter values are of the same type (e.g. a "No Break" value for an otherwise numeric set of Charpy Izod test results).  If used, then the "format" attribute on each "Data" item should be individually set.

    `ParameterValue` is composed of the following elements.

    - `Data` contains the property data and has one required attribute, format, for indicating the format of the data. `Data` must occur once and only once within the `ParameterValue` element.
    - `Qualifier` contains any qualifier(s) pertinent to the data in `ParameterValue` (e.g. "min," "max," etc.) and may occur zero or more times within the `PropertyData` element.
    - `Uncertainty` contains the measurement uncertainty(ies) of the data in `ParameterValue` and may occur once or not at all within the `ParameterValue` element. For additional information, see the documentation for the `Uncertainty` element.
    - `Notes` contains any additional information concerning the property data and may occur once or not at all within the `PropertyData` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        parameter: str = None,
        format: DataFormat = None,
        Data: DataType = None,
        Uncertainty: Uncertainty = None,
        Qualifier: str = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.parameter = _cast(None, parameter)
        self.parameter_nsprefix_ = None
        self.format = _cast(None, format)
        self.format_nsprefix_ = None
        self.Data = Data
        self.Data_nsprefix_ = None
        if Uncertainty is None:
            self.Uncertainty = []
        else:
            self.Uncertainty = Uncertainty
        self.Uncertainty_nsprefix_ = None
        if Qualifier is None:
            self.Qualifier = []
        else:
            self.Qualifier = Qualifier
        self.Qualifier_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return ParameterValue(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Data(self):
        return self.Data

    def set_Data(self, Data):
        self.Data = Data

    DataProp = property(get_Data, set_Data)

    def get_Uncertainty(self):
        return self.Uncertainty

    def set_Uncertainty(self, Uncertainty):
        self.Uncertainty = Uncertainty

    def add_Uncertainty(self, value):
        self.Uncertainty.append(value)

    def insert_Uncertainty_at(self, index, value):
        self.Uncertainty.insert(index, value)

    def replace_Uncertainty_at(self, index, value):
        self.Uncertainty[index] = value

    UncertaintyProp = property(get_Uncertainty, set_Uncertainty)

    def get_Qualifier(self):
        return self.Qualifier

    def set_Qualifier(self, Qualifier):
        self.Qualifier = Qualifier

    def add_Qualifier(self, value):
        self.Qualifier.append(value)

    def insert_Qualifier_at(self, index, value):
        self.Qualifier.insert(index, value)

    def replace_Qualifier_at(self, index, value):
        self.Qualifier[index] = value

    QualifierProp = property(get_Qualifier, set_Qualifier)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_parameter(self):
        return self.parameter

    def set_parameter(self, parameter):
        self.parameter = parameter

    parameterProp = property(get_parameter, set_parameter)

    def get_format(self):
        return self.format

    def set_format(self, format):
        self.format = format

    formatProp = property(get_format, set_format)

    def has__content(self):
        if (
            self.Data is not None
            or self.Uncertainty
            or self.Qualifier
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ParameterValue",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "ParameterValue":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="ParameterValue"
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="ParameterValue",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="ParameterValue",
    ):
        if self.parameter is not None and "parameter" not in already_processed:
            already_processed.add("parameter")
            outfile.write(" parameter=%s" % (quote_attrib(self.parameter),))
        if self.format is not None and "format" not in already_processed:
            already_processed.add("format")
            outfile.write(" format=%s" % (quote_attrib(self.format),))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ParameterValue",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Data is not None:
            namespaceprefix = (
                self.Data_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Data_nsprefix_)
                else ""
            )
            self.Data.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Data",
                pretty_print=pretty_print,
            )
        for Uncertainty_ in self.Uncertainty:
            namespaceprefix = (
                self.Uncertainty_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Uncertainty_nsprefix_)
                else ""
            )
            Uncertainty_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Uncertainty",
                pretty_print=pretty_print,
            )
        for Qualifier_ in self.Qualifier:
            namespaceprefix = (
                self.Qualifier_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Qualifier_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sQualifier>%s</%sQualifier>%s"
                % (
                    namespaceprefix,
                    quote_xml(Qualifier_),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("parameter", node)
        if value is not None and "parameter" not in already_processed:
            already_processed.add("parameter")
            self.parameter = value
        value = find_attr_value_("format", node)
        if value is not None and "format" not in already_processed:
            already_processed.add("format")
            self.format = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Data":
            obj_ = DataType.factory(parent_object_=self)
            obj_.build(child_)
            self.Data = obj_
            obj_.original_tagname_ = "Data"
        elif nodeName == "Uncertainty":
            obj_ = Uncertainty.factory(parent_object_=self)
            obj_.build(child_)
            self.Uncertainty.append(obj_)
            obj_.original_tagname_ = "Uncertainty"
        elif nodeName == "Qualifier":
            value_ = child_.text

            self.Qualifier.append(value_)
            self.Qualifier_nsprefix_ = child_.prefix
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class PhaseComposition(GeneratedsSuper):
    """This element declares the content model for `PhaseComposition`, which contains a description of a phase that comprises the bulk material or component and is composed of the following elements.

    - `Name` contains the name of the phase and has one optional attribute, authority, for identifying an authoritative source of phase names. `Name` must occur once and only once within the `PhaseComposition` element.
    - `Concentration` contains the concentration of the phase and may occur once or not at all within the `PhaseComposition` element. For additional information, see the documentation for the `Concentration` element.
    - `PropertyData` contains property data for the phase and may occur zero or more times within the `PhaseComposition` element. For additional information, see the documentation for the `PropertyData` element.
    - `Notes` contains any additional information concerning the phase and may occur once or not at all within the `PhaseComposition` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Name: Name = None,
        Concentration: Concentration = None,
        PropertyData: PropertyData = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Concentration = Concentration
        self.Concentration_nsprefix_ = None
        if PropertyData is None:
            self.PropertyData = []
        else:
            self.PropertyData = PropertyData
        self.PropertyData_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return PhaseComposition(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Concentration(self):
        return self.Concentration

    def set_Concentration(self, Concentration):
        self.Concentration = Concentration

    ConcentrationProp = property(get_Concentration, set_Concentration)

    def get_PropertyData(self, property=None):
        if property is not None:
            properties = []
            for property_data in self.get_PropertyData():
                if property_data.get_property() == property:
                    properties.append(property_data)
            return properties
        return self.PropertyData

    def set_PropertyData(self, PropertyData):
        self.PropertyData = PropertyData

    def add_PropertyData(self, value):
        self.PropertyData.append(value)

    def insert_PropertyData_at(self, index, value):
        self.PropertyData.insert(index, value)

    def replace_PropertyData_at(self, index, value):
        self.PropertyData[index] = value

    PropertyDataProp = property(get_PropertyData, set_PropertyData)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Name is not None
            or self.Concentration is not None
            or self.PropertyData
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="PhaseComposition",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "PhaseComposition":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="PhaseComposition",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="PhaseComposition",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Concentration is not None:
            namespaceprefix = (
                self.Concentration_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Concentration_nsprefix_)
                else ""
            )
            self.Concentration.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Concentration",
                pretty_print=pretty_print,
            )
        for PropertyData_ in self.PropertyData:
            namespaceprefix = (
                self.PropertyData_nsprefix_ + ":"
                if (UseCapturedNS_ and self.PropertyData_nsprefix_)
                else ""
            )
            PropertyData_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="PropertyData",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Concentration":
            obj_ = Concentration.factory(parent_object_=self)
            obj_.build(child_)
            self.Concentration = obj_
            obj_.original_tagname_ = "Concentration"
        elif nodeName == "PropertyData":
            obj_ = PropertyData.factory(parent_object_=self)
            obj_.build(child_)
            self.PropertyData.append(obj_)
            obj_.original_tagname_ = "PropertyData"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class ProcessingDetails(GeneratedsSuper):
    """This element declares the content model for `ProcessingDetails`, which contains a description of a processing step for the bulk material or component. `ProcessingDetails` is composed of the following elements.

    - `Name` contains the name of the processing step and has one optional attribute, `authority`, for identifying an authoritative source of processing step names. Name must occur once and only once within the `ProcessingDetails` element.
    - `ParameterValue` contains the value of a parameter under which the processing step occurred and may occur zero or more times within the `ProcessingDetails` element. For additional information, see the documentation for the `ParameterValue` element.
    - `Result` is a string that contains a description of the outcome or result of the processing step and may occur once or not at all within the `ProcessingDetails` element.
    - `Notes` contains any additional information concerning the processing step and may occur once or not at all within the `ProcessingDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        Name: Name = None,
        ParameterValue: ParameterValue = None,
        Result: str = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        if ParameterValue is None:
            self.ParameterValue = []
        else:
            self.ParameterValue = ParameterValue
        self.ParameterValue_nsprefix_ = None
        self.Result = Result
        self.Result_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return ProcessingDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_ParameterValue(self, parameter=None):
        if parameter is not None:
            parameters = []
            for parameter_value in self.get_ParameterValue():
                if parameter_value.get_property() == property:
                    parameters.append(parameter_value)
            return parameters
        return self.ParameterValue

    def set_ParameterValue(self, ParameterValue):
        self.ParameterValue = ParameterValue

    def add_ParameterValue(self, value):
        self.ParameterValue.append(value)

    def insert_ParameterValue_at(self, index, value):
        self.ParameterValue.insert(index, value)

    def replace_ParameterValue_at(self, index, value):
        self.ParameterValue[index] = value

    ParameterValueProp = property(get_ParameterValue, set_ParameterValue)

    def get_Result(self):
        return self.Result

    def set_Result(self, Result):
        self.Result = Result

    ResultProp = property(get_Result, set_Result)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def has__content(self):
        if (
            self.Name is not None
            or self.ParameterValue
            or self.Result is not None
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ProcessingDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "ProcessingDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="ProcessingDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ProcessingDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        for ParameterValue_ in self.ParameterValue:
            namespaceprefix = (
                self.ParameterValue_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ParameterValue_nsprefix_)
                else ""
            )
            ParameterValue_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ParameterValue",
                pretty_print=pretty_print,
            )
        if self.Result is not None:
            namespaceprefix = (
                self.Result_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Result_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sResult>%s</%sResult>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Result),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "ParameterValue":
            obj_ = ParameterValue.factory(parent_object_=self)
            obj_.build(child_)
            self.ParameterValue.append(obj_)
            obj_.original_tagname_ = "ParameterValue"
        elif nodeName == "Result":
            value_ = child_.text
            self.Result = value_
            self.Result_nsprefix_ = child_.prefix
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class PropertyData(GeneratedsSuper):
    """This element declares the content model for `PropertyData`, which contains property data. `PropertyData` has seven attributes.

    1. The first attribute, `property`, is required and references an id attribute specified in a `PropertyDetails` element so that the descriptive details for the property are tied to the data found in the `Data` element.
    2. The second attribute, `technique`, is optional and references an id attribute Specified in a `MeasurementTechniqueDetails` element so that the Descriptive details for the measurement technique are tied to the data found In the `Data` element.
    3. The third attribute, `source`, is optional and references an id attribute specified in a `DataSourceDetails` element so that the descriptive details for the data source are tied to the data found in the `Data` element.
    4. The fourth attribute, `specimen`, is optional and references an id attribute specified in a `SpecimenDetails` element so that the descriptive details for the specimen are tied to the data found in the `Data` element.
    5. The fifth attribute, `test`, is optional and references an id attribute specified in a `TestCondtionDetails` element so that the descriptive details for the test condition(s) are tied to the data found in the `Data` element.
    6. The sixth attribute, `delimiter`, specifies the delimiter that separates multiple values in the `Data`, `Qualifier`, `Uncertainty`, and `ParameterValue` elements.  The default value is a comma (',').
    7. The seventh attribute, `quote`, specifies the string that is used to quote values in the `Data`, `Qualifier`, `Uncertainty` and `ParameterValue` elements.  The default value is a null string, which is equivalent to saying that the values are not quoted.

    `PropertyData` is composed of the following elements.

    - `Data` contains the property data and has one required attribute, `format`, for indicating the format of the data. `Data` must occur once and only once within the `PropertyData` element.
    - `Qualifier` contains any qualifier(s) pertinent to the data in Data (e.g. "min," "max," etc.) and may occur once or not at all within the `PropertyData` element.
    - `Uncertainty` contains the measurement uncertainty(ies) of the data in `Data` and may occur once or not at all within the `PropertyData` element. For additional information, see the documentation for the Uncertainty element.
    - `ParameterValue` contains the value(s) of a parameter under which the data were determined and may occur zero or more times within the `PropertyData` element. For additional information, see the documentation for the `ParameterValue` element.
    - `Notes` contains any additional information concerning the property data and may occur once or not at all within the `PropertyData` element.

    Note -	Multiple entries in the `Data`, `Qualifier`, `UncertaintyValue`, and `ParameterValue` elements must be comma delimited and synchronized across elements, i.e., the number of entries in each of these four elements must be equal.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        property: str = None,
        technique: str = None,
        source: str = None,
        specimen: str = None,
        test: str = None,
        delimiter: str = ",",
        quote: str = None,
        Data: DataType = None,
        Uncertainty: Uncertainty = None,
        Qualifier: str = None,
        ParameterValue: ParameterValue = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.property = _cast(None, property)
        self.property_nsprefix_ = None
        self.technique = _cast(None, technique)
        self.technique_nsprefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None
        self.specimen = _cast(None, specimen)
        self.specimen_nsprefix_ = None
        self.test = _cast(None, test)
        self.test_nsprefix_ = None
        self.delimiter = _cast(None, delimiter)
        self.delimiter_nsprefix_ = None
        self.quote = _cast(None, quote)
        self.quote_nsprefix_ = None
        self.Data = Data
        self.Data_nsprefix_ = None
        if Uncertainty is None:
            self.Uncertainty = []
        else:
            self.Uncertainty = Uncertainty
        self.Uncertainty_nsprefix_ = None
        if Qualifier is None:
            self.Qualifier = []
        else:
            self.Qualifier = Qualifier
        self.Qualifier_nsprefix_ = None
        if ParameterValue is None:
            self.ParameterValue = []
        else:
            self.ParameterValue = ParameterValue
        self.ParameterValue_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return PropertyData(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Data(self):
        return self.Data

    def set_Data(self, Data):
        self.Data = Data

    DataProp = property(get_Data, set_Data)

    def get_Uncertainty(self):
        return self.Uncertainty

    def set_Uncertainty(self, Uncertainty):
        self.Uncertainty = Uncertainty

    def add_Uncertainty(self, value):
        self.Uncertainty.append(value)

    def insert_Uncertainty_at(self, index, value):
        self.Uncertainty.insert(index, value)

    def replace_Uncertainty_at(self, index, value):
        self.Uncertainty[index] = value

    UncertaintyProp = property(get_Uncertainty, set_Uncertainty)

    def get_Qualifier(self):
        return self.Qualifier

    def set_Qualifier(self, Qualifier):
        self.Qualifier = Qualifier

    def add_Qualifier(self, value):
        self.Qualifier.append(value)

    def insert_Qualifier_at(self, index, value):
        self.Qualifier.insert(index, value)

    def replace_Qualifier_at(self, index, value):
        self.Qualifier[index] = value

    QualifierProp = property(get_Qualifier, set_Qualifier)

    def get_ParameterValue(self, parameter=None):
        if parameter is not None:
            parameters = []
            for parameter_value in self.get_ParameterValue():
                if parameter_value.get_property() == property:
                    parameters.append(parameter_value)
            return parameters
        return self.ParameterValue

    def set_ParameterValue(self, ParameterValue):
        self.ParameterValue = ParameterValue

    def add_ParameterValue(self, value):
        self.ParameterValue.append(value)

    def insert_ParameterValue_at(self, index, value):
        self.ParameterValue.insert(index, value)

    def replace_ParameterValue_at(self, index, value):
        self.ParameterValue[index] = value

    ParameterValueProp = property(get_ParameterValue, set_ParameterValue)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_property(self):
        return self.property

    def set_property(self, property):
        self.property = property

    propertyProp = property(get_property, set_property)

    def get_technique(self):
        return self.technique

    def set_technique(self, technique):
        self.technique = technique

    techniqueProp = property(get_technique, set_technique)

    def get_source(self):
        return self.source

    def set_source(self, source):
        self.source = source

    sourceProp = property(get_source, set_source)

    def get_specimen(self):
        return self.specimen

    def set_specimen(self, specimen):
        self.specimen = specimen

    specimenProp = property(get_specimen, set_specimen)

    def get_test(self):
        return self.test

    def set_test(self, test):
        self.test = test

    testProp = property(get_test, set_test)

    def get_delimiter(self):
        return self.delimiter

    def set_delimiter(self, delimiter):
        self.delimiter = delimiter

    delimiterProp = property(get_delimiter, set_delimiter)

    def get_quote(self):
        return self.quote

    def set_quote(self, quote):
        self.quote = quote

    quoteProp = property(get_quote, set_quote)

    def has__content(self):
        if (
            self.Data is not None
            or self.Uncertainty
            or self.Qualifier
            or self.ParameterValue
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="PropertyData",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "PropertyData":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="PropertyData"
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="PropertyData",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="PropertyData",
    ):
        if self.property is not None and "property" not in already_processed:
            already_processed.add("property")
            outfile.write(" property=%s" % (quote_attrib(self.property),))
        if self.technique is not None and "technique" not in already_processed:
            already_processed.add("technique")
            outfile.write(" technique=%s" % (quote_attrib(self.technique),))
        if self.source is not None and "source" not in already_processed:
            already_processed.add("source")
            outfile.write(" source=%s" % (quote_attrib(self.source),))
        if self.specimen is not None and "specimen" not in already_processed:
            already_processed.add("specimen")
            outfile.write(" specimen=%s" % (quote_attrib(self.specimen),))
        if self.test is not None and "test" not in already_processed:
            already_processed.add("test")
            outfile.write(" test=%s" % (quote_attrib(self.test)))
        if self.delimiter != "," and "delimiter" not in already_processed:
            already_processed.add("delimiter")
            outfile.write(" delimiter=%s" % (quote_attrib(self.delimiter),))
        if self.quote is not None and "quote" not in already_processed:
            already_processed.add("quote")
            outfile.write(" quote=%s" % (quote_attrib(self.quote),))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="PropertyData",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Data is not None:
            namespaceprefix = (
                self.Data_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Data_nsprefix_)
                else ""
            )
            self.Data.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Data",
                pretty_print=pretty_print,
            )
        for Uncertainty_ in self.Uncertainty:
            namespaceprefix = (
                self.Uncertainty_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Uncertainty_nsprefix_)
                else ""
            )
            Uncertainty_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Uncertainty",
                pretty_print=pretty_print,
            )
        for Qualifier_ in self.Qualifier:
            namespaceprefix = (
                self.Qualifier_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Qualifier_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sQualifier>%s</%sQualifier>%s"
                % (
                    namespaceprefix,
                    quote_xml(Qualifier_),
                    namespaceprefix,
                    eol,
                )
            )
        for ParameterValue_ in self.ParameterValue:
            namespaceprefix = (
                self.ParameterValue_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ParameterValue_nsprefix_)
                else ""
            )
            ParameterValue_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ParameterValue",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("property", node)
        if value is not None and "property" not in already_processed:
            already_processed.add("property")
            self.property = value
        value = find_attr_value_("technique", node)
        if value is not None and "technique" not in already_processed:
            already_processed.add("technique")
            self.technique = value
        value = find_attr_value_("source", node)
        if value is not None and "source" not in already_processed:
            already_processed.add("source")
            self.source = value
        value = find_attr_value_("specimen", node)
        if value is not None and "specimen" not in already_processed:
            already_processed.add("specimen")
            self.specimen = value
        value = find_attr_value_("test", node)
        if value is not None and "test" not in already_processed:
            already_processed.add("test")
            self.test = value
        value = find_attr_value_("delimiter", node)
        if value is not None and "delimiter" not in already_processed:
            already_processed.add("delimiter")
            self.delimiter = value
        value = find_attr_value_("quote", node)
        if value is not None and "quote" not in already_processed:
            already_processed.add("quote")
            self.quote = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Data":
            obj_ = DataType.factory(parent_object_=self)
            obj_.build(child_)
            self.Data = obj_
            obj_.original_tagname_ = "Data"
        elif nodeName == "Uncertainty":
            obj_ = Uncertainty.factory(parent_object_=self)
            obj_.build(child_)
            self.Uncertainty.append(obj_)
            obj_.original_tagname_ = "Uncertainty"
        elif nodeName == "Qualifier":
            value_ = child_.text

            self.Qualifier.append(value_)
            self.Qualifier_nsprefix_ = child_.prefix

        elif nodeName == "ParameterValue":
            obj_ = ParameterValue.factory(parent_object_=self)
            obj_.build(child_)
            self.ParameterValue.append(obj_)
            obj_.original_tagname_ = "ParameterValue"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class Source(GeneratedsSuper):
    """This element declares the content model for `Source`, which contains an `id` attribute specified in a `SourceDetails` element representing the source of the bulk material or component."""

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, source: str = None, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.source = _cast(None, source)
        self.source_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Source(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_source(self):
        return self.source

    def set_source(self, source):
        self.source = source

    sourceProp = property(get_source, set_source)

    def has__content(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Source",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Source":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="Source"
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))

            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix="", name_="Source"
    ):
        if self.source is not None and "source" not in already_processed:
            already_processed.add("source")
            outfile.write(" source=%s" % (quote_attrib(self.source),))

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]

        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("source", node)
        if value is not None and "source" not in already_processed:
            already_processed.add("source")
            self.source = value


class Specification(GeneratedsSuper):
    """This element declares the content model for `Specification`, which contains a string representing the specification for the bulk material or component and has one optional attribute, `authority`, for identifying an authoritative source of specifications."""

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, authority: str = None, valueOf_=None, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.authority = _cast(None, authority)
        self.authority_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs):

        return Specification(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_authority(self):
        return self.authority

    def set_authority(self, authority):
        self.authority = authority

    authorityProp = property(get_authority, set_authority)

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def has__content(self):
        if 1 if type(self.valueOf_) in [int, float] else self.valueOf_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Specification",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Specification":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="Specification"
        )
        outfile.write(">")

        outfile.write(quote_xml(self.valueOf_))
        outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="Specification",
    ):
        if self.authority is not None and "authority" not in already_processed:
            already_processed.add("authority")
            outfile.write(" authority=%s" % (quote_attrib(self.authority),))

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]

        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("authority", node)
        if value is not None and "authority" not in already_processed:
            already_processed.add("authority")
            self.authority = value


class Uncertainty(GeneratedsSuper):
    """This element declares the content model for `Uncertainty`, which contains a description of the measurement uncertainty of the data.

    `Uncertainty` has 1 optional attributes:

    1. `Name` is a description of the nature of the uncertainty value, for example '6 sigma', 'Gaussian' or '2 std dev.'

    Uncertainty is composed of the following elements.

    - `Value` contains the value of the uncertainty and has one required attribute, format, for indicating the format of the value. `Value` must occur once and only once within the `Uncertainty` element.
    - `Units` contains the units for the value of the uncertainty and must occur once and only once within the `Uncertainty` element. For additional information, see the documentation for the `Units` element.
    - `Percentile` is a value indicating the percentage of the data population that have values less than or equal to that expressed by the `Uncertainty` value.  `Percentile` can occur zero or more times.  If `Percentile` is not given then `Value` is interpreted as being an equal and unspecified deviation above and below the property value(s). An uncertainty of 2 standard deviations below  the mean for a normally distributed dataset would have a uncertainty percentile of 5%, and 2 standard deviations above the mean would be 95%.
    - `Notes` contains any additional information concerning the uncertainty, such as a description of the evaluation of the uncertainty, and may occur once or not at all within the `Uncertainty` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        DistributionType: str = "Normal/Gaussian",
        Num_Std_Dev: float = 2,
        Percentile: float = None,
        ConfidenceLevel: float = None,
        Value: str = None,
        Units: Units = None,
        Unitless: Unitless = None,
        Notes: str = None,
        Scale="Linear",
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.DistributionType = _cast(None, DistributionType)
        self.DistributionType_nsprefix_ = None
        self.Num_Std_Dev = _cast(float, Num_Std_Dev)
        self.Num_Std_Dev_nsprefix_ = None
        self.Percentile = _cast(float, Percentile)
        self.Percentile_nsprefix_ = None
        self.ConfidenceLevel = _cast(float, ConfidenceLevel)
        self.ConfidenceLevel_nsprefix_ = None
        self.Value = Value
        self.Value_nsprefix_ = None
        self.Units = Units
        self.Units_nsprefix_ = None
        self.Unitless = Unitless
        self.Unitless_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None
        self.Scale = Scale
        self.Scale_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Uncertainty(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Value(self):
        return self.Value

    def set_Value(self, Value):
        self.Value = Value

    ValueProp = property(get_Value, set_Value)

    def get_Units(self):
        return self.Units

    def set_Units(self, Units):
        self.Units = Units

    UnitsProp = property(get_Units, set_Units)

    def get_Unitless(self):
        return self.Unitless

    def set_Unitless(self, Unitless):
        self.Unitless = Unitless

    UnitlessProp = property(get_Unitless, set_Unitless)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_Scale(self):
        return self.Scale

    def set_Scale(self, Scale):
        self.Scale = Scale

    ScaleProp = property(get_Scale, set_Scale)

    def get_DistributionType(self):
        return self.DistributionType

    def set_DistributionType(self, DistributionType):
        self.DistributionType = DistributionType

    DistributionTypeProp = property(get_DistributionType, set_DistributionType)

    def get_Num_Std_Dev(self):
        return self.Num_Std_Dev

    def set_Num_Std_Dev(self, Num_Std_Dev):
        self.Num_Std_Dev = Num_Std_Dev

    Num_Std_DevProp = property(get_Num_Std_Dev, set_Num_Std_Dev)

    def get_Percentile(self):
        return self.Percentile

    def set_Percentile(self, Percentile):
        self.Percentile = Percentile

    PercentileProp = property(get_Percentile, set_Percentile)

    def get_ConfidenceLevel(self):
        return self.ConfidenceLevel

    def set_ConfidenceLevel(self, ConfidenceLevel):
        self.ConfidenceLevel = ConfidenceLevel

    ConfidenceLevelProp = property(get_ConfidenceLevel, set_ConfidenceLevel)

    def has__content(self):
        if (
            self.Value is not None
            or self.Units is not None
            or self.Unitless is not None
            or self.Notes is not None
            or self.Scale != "Linear"
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Uncertainty",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Uncertainty":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="Uncertainty"
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Uncertainty",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="Uncertainty",
    ):
        if (
            self.DistributionType != "Normal/Gaussian"
            and "DistributionType" not in already_processed
        ):
            already_processed.add("DistributionType")
            outfile.write(
                " DistributionType=%s" % (quote_attrib(self.DistributionType),)
            )
        if self.Num_Std_Dev != 2 and "Num_Std_Dev" not in already_processed:
            already_processed.add("Num_Std_Dev")
            outfile.write(' Num_Std_Dev="%s"' % float(self.Num_Std_Dev))
        if self.Percentile is not None and "Percentile" not in already_processed:
            already_processed.add("Percentile")
            outfile.write(' Percentile="%s"' % float(self.Percentile))
        if (
            self.ConfidenceLevel is not None
            and "ConfidenceLevel" not in already_processed
        ):
            already_processed.add("ConfidenceLevel")
            outfile.write(' ConfidenceLevel="%s"' % float(self.ConfidenceLevel))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Uncertainty",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Value is not None:
            namespaceprefix = (
                self.Value_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Value_nsprefix_)
                else ""
            )
            self.Value.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Value",
                pretty_print=pretty_print,
            )
        if self.Units is not None:
            namespaceprefix = (
                self.Units_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Units_nsprefix_)
                else ""
            )
            self.Units.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Units",
                pretty_print=pretty_print,
            )
        if self.Unitless is not None:
            namespaceprefix = (
                self.Unitless_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Unitless_nsprefix_)
                else ""
            )
            self.Unitless.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Unitless",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Scale != "Linear":
            namespaceprefix = (
                self.Scale_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Scale_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sScale>%s</%sScale>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Scale),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("DistributionType", node)
        if value is not None and "DistributionType" not in already_processed:
            already_processed.add("DistributionType")
            self.DistributionType = value
        value = find_attr_value_("Num_Std_Dev", node)
        if value is not None and "Num_Std_Dev" not in already_processed:
            already_processed.add("Num_Std_Dev")
            value = float(node)
            self.Num_Std_Dev = value
        value = find_attr_value_("Percentile", node)
        if value is not None and "Percentile" not in already_processed:
            already_processed.add("Percentile")
            value = float(value)
            self.Percentile = value
        value = find_attr_value_("ConfidenceLevel", node)
        if value is not None and "ConfidenceLevel" not in already_processed:
            already_processed.add("ConfidenceLevel")
            value = float(value)
            self.ConfidenceLevel = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Value":
            obj_ = Value.factory(parent_object_=self)
            obj_.build(child_)
            self.Value = obj_
            obj_.original_tagname_ = "Value"
        elif nodeName == "Units":
            obj_ = Units.factory(parent_object_=self)
            obj_.build(child_)
            self.Units = obj_
            obj_.original_tagname_ = "Units"
        elif nodeName == "Unitless":
            obj_ = Unitless.factory(parent_object_=self)
            obj_.build(child_)
            self.Unitless = obj_
            obj_.original_tagname_ = "Unitless"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix
        elif nodeName == "Scale":
            value_ = child_.text
            self.Scale = value_
            self.Scale_nsprefix_ = child_.prefix


class Unit(GeneratedsSuper):
    """This element declares the content model for `Unit`, which contains a unit and has two optional attributes.

    1. The first attribute, `power`, is used to indicate the exponent for `Unit`.
    2. The second attribute, `description`, is used to describe `Unit`.

    Note -	Multiple `Unit` elements are multiplied together to form units. Division is specified by setting the `power` attribute of `Unit` equal to "-1." For additional information, see the documentation for the `Units` element.

    `Unit` has a choice between two elements:

    - `Name` is the `Name` of the unit, and can occur only once in the Unit element.
    - `Currency` is the `CurrencyCode` for the unit, if it is a unit expressing cost in an ISO 4217 recognised currency.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        power: float = None,
        description: str = None,
        Name: str = None,
        Currency: CurrencyCode = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.power = _cast(float, power)
        self.power_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Currency = Currency
        self.Currency_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Unit(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Currency(self):
        return self.Currency

    def set_Currency(self, Currency):
        self.Currency = Currency

    CurrencyProp = property(get_Currency, set_Currency)

    def get_power(self):
        return self.power

    def set_power(self, power):
        self.power = power

    powerProp = property(get_power, set_power)

    def get_description(self):
        return self.description

    def set_description(self, description):
        self.description = description

    descriptionProp = property(get_description, set_description)

    def has__content(self):
        if self.Name is not None or self.Currency is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Unit",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Unit":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="Unit"
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Unit",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix="", name_="Unit"
    ):
        if self.power is not None and "power" not in already_processed:
            already_processed.add("power")
            outfile.write(' power="%s"' % str(self.power))
        if self.description is not None and "description" not in already_processed:
            already_processed.add("description")
            outfile.write(" description=%s" % (quote_attrib(self.description),))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Unit",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sName>%s</%sName>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Name),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Currency is not None:
            namespaceprefix = (
                self.Currency_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Currency_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sCurrency>%s</%sCurrency>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Currency),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("power", node)
        if value is not None and "power" not in already_processed:
            already_processed.add("power")
            value = decimal.Decimal(value)
            self.power = value
        value = find_attr_value_("description", node)
        if value is not None and "description" not in already_processed:
            already_processed.add("description")
            self.description = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            value_ = child_.text
            self.Name = value_
            self.Name_nsprefix_ = child_.prefix
        elif nodeName == "Currency":
            value_ = child_.text
            self.Currency = value_
            self.Currency_nsprefix_ = child_.prefix


class Unitless(GeneratedsSuper):
    """This element declares the content model for `Unitless`, which is an empty element used whenever a property, parameter, or uncertainty value has no units."""

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None

    def factory(*args_, **kwargs):

        return Unitless(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def has__content(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Unitless",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Unitless":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        if self.has__content():
            outfile.write(">%s" % (eol,))

            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def build(self, node):

        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]

        return self


class Units(GeneratedsSuper):
    """This element declares the content model for `Units`, which contains units and has four optional attributes.

    1. The first attribute, `system`, is used to indicate the units system, such as "SI."
    2. The second attribute, `factor`, is used to indicate a constant multiplier in floating point format.
    3. The third attribute, `name`, is used to indicate the name of the units
    4. The fourth attribute, `description`, is used to describe the units.

    `Units` is composed of the following elements.

    - `Unit` contains a unit and must occur one or more times within the `Units` element. For additional information, see the documentation for the `Unit` element.

    Note -	Multiple `Unit` elements are multiplied together to form the units. Division is specified by using setting the `power` attribute of `Unit` equal to "-1."
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        system: str = None,
        factor: float = None,
        name: str = None,
        description: str = None,
        Unit=None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.system = _cast(None, system)
        self.system_nsprefix_ = None
        self.factor = _cast(float, factor)
        self.factor_nsprefix_ = None
        self.name = _cast(None, name)
        self.name_nsprefix_ = None
        self.description = _cast(None, description)
        self.description_nsprefix_ = None
        if Unit is None:
            self.Unit = []
        else:
            self.Unit = Unit
        self.Unit_nsprefix_ = None

    def factory(*args_, **kwargs):

        return Units(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Unit(self):
        return self.Unit

    def set_Unit(self, Unit):
        self.Unit = Unit

    def add_Unit(self, value):
        self.Unit.append(value)

    def insert_Unit_at(self, index, value):
        self.Unit.insert(index, value)

    def replace_Unit_at(self, index, value):
        self.Unit[index] = value

    UnitProp = property(get_Unit, set_Unit)

    def get_system(self):
        return self.system

    def set_system(self, system):
        self.system = system

    systemProp = property(get_system, set_system)

    def get_factor(self):
        return self.factor

    def set_factor(self, factor):
        self.factor = factor

    factorProp = property(get_factor, set_factor)

    def get_name(self):
        return self.name

    def set_name(self, name):
        self.name = name

    nameProp = property(get_name, set_name)

    def get_description(self):
        return self.description

    def set_description(self, description):
        self.description = description

    descriptionProp = property(get_description, set_description)

    def has__content(self):
        if self.Unit:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Units",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Units":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="Units"
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="Units",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def string(self, format: str | None = None) -> str:
        """Returns a formatted representation of the Units.

        Args:
            format (str | None, optional): the units string formatter. Say your units are pound-force (lbf) per square inch (in), the following formats will return: Defaults to None.

            - format = 'explicit': 'lbf^1Â·in^-2'
            - format = 'short': 'lbfÂ·in^-2'
            - format = None (default): 'lbf / in^-2'

        Returns:
            str: the formatted string representation
        """
        s = ""
        match format:
            case "explicit":
                for unit in self.Unit:
                    u = unit.Name if unit.Name is not None else unit.Currency._value_
                    power = 1.0 if unit.power is None else float(unit.power)
                    s += u + "^" + str(power) + "Â·"
                return s[0 : len(s) - 3]
            case "short":
                for unit in self.Unit:
                    u = unit.Name if unit.Name is not None else unit.Currency._value_
                    power = 1.0 if unit.power is None else float(unit.power)
                    if power == 1.0:
                        s += u + "Â·"
                    elif power.is_integer():
                        s += u + "^" + str(int(power)) + "Â·"
                    else:
                        s += u + "^" + str(power) + "Â·"
                return s[0 : len(s) - 1]
            case _:
                numerator = ""
                denominator = ""
                for unit in self.Unit:
                    u = unit.Name if unit.Name is not None else unit.Currency._value_
                    power = 1.0 if unit.power is None else float(unit.power)
                    if power > 0:
                        if power == 1.0:
                            numerator += u + "Â·"
                        elif power.is_integer():
                            numerator += u + "^" + str(int(power)) + "Â·"
                        else:
                            numerator += u + "^" + str(power) + "Â·"
                    elif power < 0:
                        if power == -1.0:
                            denominator += u + "Â·"
                        elif power.is_integer():
                            denominator += u + "^" + str(abs(int(power))) + "Â·"
                        else:
                            denominator += u + "^" + str(abs(power)) + "Â·"
                if len(denominator) == 0:
                    return numerator[0:-1]
                else:
                    return numerator[0:-1] + " / " + denominator[0:-1]

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix="", name_="Units"
    ):
        if self.system is not None and "system" not in already_processed:
            already_processed.add("system")
            outfile.write(" system=%s" % (quote_attrib(self.system),))
        if self.factor is not None and "factor" not in already_processed:
            already_processed.add("factor")
            outfile.write(' factor="%s"' % float(self.factor))
        if self.name is not None and "name" not in already_processed:
            already_processed.add("name")
            outfile.write(" name=%s" % (quote_attrib(self.name)))
        if self.description is not None and "description" not in already_processed:
            already_processed.add("description")
            outfile.write(" description=%s" % (quote_attrib(self.description),))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Units",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        for Unit_ in self.Unit:
            namespaceprefix = (
                self.Unit_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Unit_nsprefix_)
                else ""
            )
            Unit_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Unit",
                pretty_print=pretty_print,
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("system", node)
        if value is not None and "system" not in already_processed:
            already_processed.add("system")
            self.system = value
        value = find_attr_value_("factor", node)
        if value is not None and "factor" not in already_processed:
            already_processed.add("factor")
            value = float(value)
            self.factor = value
        value = find_attr_value_("name", node)
        if value is not None and "name" not in already_processed:
            already_processed.add("name")
            self.name = value
        value = find_attr_value_("description", node)
        if value is not None and "description" not in already_processed:
            already_processed.add("description")
            self.description = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Unit":
            obj_ = Unit.factory(parent_object_=self)
            obj_.build(child_)
            self.Unit.append(obj_)
            obj_.original_tagname_ = "Unit"


class Value(GeneratedsSuper):
    """This element declares the content model for `Value`, which contains a string representing a value. `Value` has one required attribute, `format`, for indicating the format of the value."""

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, format: DataFormat = None, valueOf_=None, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.format = _cast(None, format)
        self.format_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs):

        return Value(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_format(self):
        return self.format

    def set_format(self, format):
        self.format = format

    formatProp = property(get_format, set_format)

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def has__content(self):
        if 1 if type(self.valueOf_) in [int, float] else self.valueOf_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="Value",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "Value":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="Value"
        )
        outfile.write(">")

        outfile.write(quote_xml(self.valueOf_))
        outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix="", name_="Value"
    ):
        if self.format is not None and "format" not in already_processed:
            already_processed.add("format")
            outfile.write(" format=%s" % (quote_attrib(self.format),))

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]

        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("format", node)
        if value is not None and "format" not in already_processed:
            already_processed.add("format")
            self.format = value


class AuthorityDetails(GeneratedsSuper):
    """This element declares the content model for `AuthorityDetails`, which contains a description of an authority referenced by other elements, such as the `Specification` and `Name` elements.  An authority is typically an organisation that is the authoritative source of information about the element that is referencing it.

    `AuthorityDetails` has one required attribute, `id`, which may be arbitrarily assigned but must be unique among `id` attributes assigned elsewhere in a MatML document.

    `AuthorityDetails` additionally has two elements, `Name` and `Notes`.

    - `Name` contains the name of the Authority.  `Name` must occur once and only once within the `AuthorityDetails` element.
    - `Notes` contains any additional information concerning the parameter and may occur once or not at all within the `AuthorityDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        id: str = None,
        Name: Name = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return AuthorityDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def has__content(self):
        if self.Name is not None or self.Notes is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="AuthorityDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "AuthorityDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix,
            name_="AuthorityDetails",
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="AuthorityDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="AuthorityDetails",
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % (quote_attrib(self.id)))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="AuthorityDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class DataSourceDetails(GeneratedsSuper):
    """This element declares the content model for `DataSourceDetails`, which contains a description of a data source referenced by the `PropertyData` element.

    `DataSourceDetails` has one required attribute, `id`, which may be arbitrarily assigned but must be unique among `id` attributes assigned elsewhere in a MatML document.

    `DataSourceDetails` also has one optional attribute, `type`, for specifying the type of the data source (examples include "unpublished report," "journal," "handbook," etc.)

    `DataSourceDetails` is composed of the following elements.

    - Name contains the name of the data source and has one optional attribute, authority, for identifying an authoritative source of data source names. Name must occur once and only once within the DataSourceDetails element.
    - Notes contains any additional information concerning the data source and may occur once or not at all within the DataSourceDetails element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        id: str = None,
        type_: str = None,
        Name: Name = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return DataSourceDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    typeProp = property(get_type, set_type)

    def has__content(self):
        if self.Name is not None or self.Notes is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="DataSourceDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "DataSourceDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix,
            name_="DataSourceDetails",
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="DataSourceDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="DataSourceDetails",
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % (quote_attrib(self.id)))
        if self.type_ is not None and "type_" not in already_processed:
            already_processed.add("type_")
            outfile.write(" type=%s" % (quote_attrib(self.type_)))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="DataSourceDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type_ = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class MeasurementTechniqueDetails(GeneratedsSuper):
    """This element declares the content model for `MeasurementTechniqueDetails`, which contains a description of a measurement technique referenced by the `PropertyData` element.

    `MeasurementTechniqueDetails` has one required attribute, `id`, which may be arbitrarily assigned but must be unique among `id` attributes assigned elsewhere in a MatML document.

    `MeasurementTechniqueDetails` is composed of the following elements.

    - `Name` contains the name of the measurement technique and has one optional attribute, `authority`, for identifying an authoritative source of measurement techniques. `Name` must occur once and only once within the `MeasurementTechniqueDetails` element.
    - `Notes` contains any additional information concerning the measurement technique, such as a description of the technique, and may occur once or not at all within the `MeasurementTechniqueDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        id: str = None,
        Name: Name = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Notes = Notes
        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return MeasurementTechniqueDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def has__content(self):
        if self.Name is not None or self.Notes is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="MeasurementTechniqueDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if (
            self.original_tagname_ is not None
            and name_ == "MeasurementTechniqueDetails"
        ):
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix,
            name_="MeasurementTechniqueDetails",
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="MeasurementTechniqueDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="MeasurementTechniqueDetails",
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % (quote_attrib(self.id)))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="MeasurementTechniqueDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class ParameterDetails(GeneratedsSuper):
    """This element declares the content model for `ParameterDetails`, which contains a description of a parameter referenced by the `ParameterValue` element.

    `ParameterDetails` has one required attribute, `id`, which may be arbitrarily assigned but must be unique among `id` attributes assigned elsewhere in a MatML document.

    `ParameterDetails` is composed of the following elements.

    - `Name` contains the name of the parameter and has one optional attribute, `authority`, for identifying an authoritative source of parameter names. `Name` must occur once and only once within the `ParameterDetails` element.
    - `Units` and `Unitless` are mutually exclusive elements for describing the parameter's units. `Units` or `Unitless` must occur once and only once within the `ParameterDetails` element. For additional information, see the documentation for the `Units` and `Unitless` elements.
    - `Notes` contains any additional information concerning the parameter and may occur once or not at all within the `ParameterDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        id: str = None,
        Name: Name = None,
        Units: Units = None,
        Unitless: Unitless = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Units = Units
        self.Units_nsprefix_ = None
        self.Unitless = Unitless
        self.Unitless_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return ParameterDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Units(self):
        return self.Units

    def set_Units(self, Units):
        self.Units = Units

    UnitsProp = property(get_Units, set_Units)

    def get_Unitless(self):
        return self.Unitless

    def set_Unitless(self, Unitless):
        self.Unitless = Unitless

    UnitlessProp = property(get_Unitless, set_Unitless)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def has__content(self):
        if (
            self.Name is not None
            or self.Units is not None
            or self.Unitless is not None
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ParameterDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "ParameterDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix,
            name_="ParameterDetails",
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="ParameterDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="ParameterDetails",
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % (quote_attrib(self.id)))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ParameterDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Units is not None:
            namespaceprefix = (
                self.Units_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Units_nsprefix_)
                else ""
            )
            self.Units.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Units",
                pretty_print=pretty_print,
            )
        if self.Unitless is not None:
            namespaceprefix = (
                self.Unitless_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Unitless_nsprefix_)
                else ""
            )
            self.Unitless.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Unitless",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Units":
            obj_ = Units.factory(parent_object_=self)
            obj_.build(child_)
            self.Units = obj_
            obj_.original_tagname_ = "Units"
        elif nodeName == "Unitless":
            obj_ = Unitless.factory(parent_object_=self)
            obj_.build(child_)
            self.Unitless = obj_
            obj_.original_tagname_ = "Unitless"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class PropertyDetails(GeneratedsSuper):
    """This element declares the content model for `PropertyDetails`, which contains a description of a property referenced by the `PropertyData` element.

    `PropertyDetails` has one required attribute, `id`, which may be arbitrarily assigned but must be unique among `id` attributes assigned elsewhere in a MatML document.

    `PropertyDetails` also has one optional attribute, `type`, for specifying the type of the property (examples include "thermal," "mechanical," "electrical," etc.).

    `PropertyDetails` is composed of the following elements.

    - `Name` contains the name of the property and has one optional attribute, `authority`, for identifying an authoritative source of property names. `Name` must occur once and only once within the `PropertyDetails` element.
    - `Units` and `Unitless` are mutually exclusive elements for describing the property's units. `Units` or `Unitless` must occur once and only once within the `PropertyDetails` element. For additional information, see the documentation for the `Units` and `Unitless` elements.
    - `Notes` contains any additional information concerning the property and may occur once or not at all within the `PropertyDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        id: str = None,
        type_: str = None,
        Name: Name = None,
        Units: Units = None,
        Unitless: Unitless = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Units = Units
        self.Units_nsprefix_ = None
        self.Unitless = Unitless
        self.Unitless_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return PropertyDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Units(self):
        return self.Units

    def set_Units(self, Units):
        self.Units = Units

    UnitsProp = property(get_Units, set_Units)

    def get_Unitless(self):
        return self.Unitless

    def set_Unitless(self, Unitless):
        self.Unitless = Unitless

    UnitlessProp = property(get_Unitless, set_Unitless)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    typeProp = property(get_type, set_type)

    def has__content(self):
        if (
            self.Name is not None
            or self.Units is not None
            or self.Unitless is not None
            or self.Notes is not None
        ):
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="PropertyDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "PropertyDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="PropertyDetails"
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="PropertyDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="PropertyDetails",
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % (quote_attrib(self.id)))
        if self.type_ is not None and "type_" not in already_processed:
            already_processed.add("type_")
            outfile.write(" type=%s" % (quote_attrib(self.type_)))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="PropertyDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Units is not None:
            namespaceprefix = (
                self.Units_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Units_nsprefix_)
                else ""
            )
            self.Units.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Units",
                pretty_print=pretty_print,
            )
        if self.Unitless is not None:
            namespaceprefix = (
                self.Unitless_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Unitless_nsprefix_)
                else ""
            )
            self.Unitless.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Unitless",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type_ = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Units":
            obj_ = Units.factory(parent_object_=self)
            obj_.build(child_)
            self.Units = obj_
            obj_.original_tagname_ = "Units"
        elif nodeName == "Unitless":
            obj_ = Unitless.factory(parent_object_=self)
            obj_.build(child_)
            self.Unitless = obj_
            obj_.original_tagname_ = "Unitless"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class SourceDetails(GeneratedsSuper):
    """This element declares the content model for `SourceDetails`, which contains the name of the source of the component.

    `Name` contains the name of the source and has one optional attribute, `Notes`.

    `Notes` contains any additional information concerning the data source and may occur once or not at all within the `DataSourceDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        id: str = None,
        type_: str = None,
        Name: Name = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return SourceDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    typeProp = property(get_type, set_type)

    def has__content(self):
        if self.Name is not None or self.Notes is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="SourceDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "SourceDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="SourceDetails"
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="SourceDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="SourceDetails",
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % (quote_attrib(self.id)))
        if self.type_ is not None and "type_" not in already_processed:
            already_processed.add("type_")
            outfile.write(" type=%s" % (quote_attrib(self.type_)))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="SourceDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type_ = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class SpecimenDetails(GeneratedsSuper):
    """This element declares the content model for `SpecimenDetails`, which contains a description of a specimen referenced by the `PropertyData` element.

    `SpecimenDetails` has one required attribute, `id`, which may be arbitrarily assigned but must be unique among `id` attributes assigned elsewhere in a MatML document.

    `SpecimenDetails` also has one optional attribute, `type`, for specifying the type of the specimen (examples include "cylindrical," "rectangular," "full cross-section," "pressed," etc.)

    `SpecimenDetails` is composed of the following elements. `SpecimenDetails` also has 3 optional elements, `Name`, `Geometry`, and `Notes`.

    - `Name` contains the name of the specimen and has one optional attribute, `authority`, for identifying an authoritative source of specimen names. `Name` may occur once or not at all within the `SpecimenDetails` element.
    - `Geometry` describes the dimensions of the Component.  For additional information, see the documentation for the `Geometry` type. `Geometry` may occur once or not at all within the `SpecimenDetails` element.
    - `Notes` contains any additional information concerning the specimen and may occur once or not at all within the `SpecimenDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        id: str = None,
        type_: str = None,
        Name: Name = None,
        Notes: str = None,
        Geometry: Geometry = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        self.type_ = _cast(None, type_)
        self.type__nsprefix_ = None
        self.Name = Name
        self.Name_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None
        self.Geometry = Geometry
        self.Geometry_nsprefix_ = None

    def factory(*args_, **kwargs):

        return SpecimenDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_Name(self):
        return self.Name

    def set_Name(self, Name):
        self.Name = Name

    NameProp = property(get_Name, set_Name)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_Geometry(self):
        return self.Geometry

    def set_Geometry(self, Geometry):
        self.Geometry = Geometry

    GeometryProp = property(get_Geometry, set_Geometry)

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def get_type(self):
        return self.type_

    def set_type(self, type_):
        self.type_ = type_

    typeProp = property(get_type, set_type)

    def has__content(self):
        if self.Name is not None or self.Notes is not None or self.Geometry is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="SpecimenDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "SpecimenDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="SpecimenDetails"
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="SpecimenDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="SpecimenDetails",
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % (quote_attrib(self.id)))
        if self.type_ is not None and "type_" not in already_processed:
            already_processed.add("type_")
            outfile.write(" type=%s" % (quote_attrib(self.type_)))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="SpecimenDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.Name is not None:
            namespaceprefix = (
                self.Name_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Name_nsprefix_)
                else ""
            )
            self.Name.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Name",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )
        if self.Geometry is not None:
            namespaceprefix = (
                self.Geometry_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Geometry_nsprefix_)
                else ""
            )
            self.Geometry.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="Geometry",
                pretty_print=pretty_print,
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value
        value = find_attr_value_("type", node)
        if value is not None and "type" not in already_processed:
            already_processed.add("type")
            self.type_ = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "Name":
            obj_ = Name.factory(parent_object_=self)
            obj_.build(child_)
            self.Name = obj_
            obj_.original_tagname_ = "Name"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix

        elif nodeName == "Geometry":
            obj_ = Geometry.factory(parent_object_=self)
            obj_.build(child_)
            self.Geometry = obj_
            obj_.original_tagname_ = "Geometry"


class TestConditionDetails(GeneratedsSuper):
    """This element declares the content model for `TestConditionDetails`, which contains a description of the test conditions referenced by the `PropertyData` element.

    `TestConditionDetails` has one required attribute, `id`, which may be arbitrarily assigned but must be unique among `id` attributes assigned elsewhere in a MatML document.

    `TestConditionDetails` has two optional elements, `ParameterValue` and `Notes`.

    - `ParameterValue` contains the value(s) of a parameter, i.e., a test condition, and may occur zero or more times within the `TestConditionDetails` element. For additional information, see the documentation for the `ParameterValue` element.
    - `Notes` contains any additional information concerning the test conditions and may occur once or not at all within the `TestConditionDetails` element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(
        self,
        id: str = None,
        ParameterValue: ParameterValue = None,
        Notes: str = None,
        **kwargs,
    ):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None
        if ParameterValue is None:
            self.ParameterValue = []
        else:
            self.ParameterValue = ParameterValue
        self.ParameterValue_nsprefix_ = None
        self.Notes = Notes

        self.Notes_nsprefix_ = None

    def factory(*args_, **kwargs):

        return TestConditionDetails(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_ParameterValue(self, parameter=None):
        if parameter is not None:
            parameters = []
            for parameter_value in self.get_ParameterValue():
                if parameter_value.get_property() == property:
                    parameters.append(parameter_value)
            return parameters
        return self.ParameterValue

    def set_ParameterValue(self, ParameterValue):
        self.ParameterValue = ParameterValue

    def add_ParameterValue(self, value):
        self.ParameterValue.append(value)

    def insert_ParameterValue_at(self, index, value):
        self.ParameterValue.insert(index, value)

    def replace_ParameterValue_at(self, index, value):
        self.ParameterValue[index] = value

    ParameterValueProp = property(get_ParameterValue, set_ParameterValue)

    def get_Notes(self):
        return self.Notes

    def set_Notes(self, Notes):
        self.Notes = Notes

    NotesProp = property(get_Notes, set_Notes)

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def has__content(self):
        if self.ParameterValue or self.Notes is not None:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="TestConditionDetails",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "TestConditionDetails":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix,
            name_="TestConditionDetails",
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="TestConditionDetails",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="TestConditionDetails",
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % (quote_attrib(self.id)))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="TestConditionDetails",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        for ParameterValue_ in self.ParameterValue:
            namespaceprefix = (
                self.ParameterValue_nsprefix_ + ":"
                if (UseCapturedNS_ and self.ParameterValue_nsprefix_)
                else ""
            )
            ParameterValue_.export(
                outfile,
                level,
                namespaceprefix,
                namespacedef="",
                name_="ParameterValue",
                pretty_print=pretty_print,
            )
        if self.Notes is not None:
            namespaceprefix = (
                self.Notes_nsprefix_ + ":"
                if (UseCapturedNS_ and self.Notes_nsprefix_)
                else ""
            )
            showIndent(outfile, level, pretty_print)
            outfile.write(
                "<%sNotes>%s</%sNotes>%s"
                % (
                    namespaceprefix,
                    quote_xml(self.Notes),
                    namespaceprefix,
                    eol,
                )
            )

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        if nodeName == "ParameterValue":
            obj_ = ParameterValue.factory(parent_object_=self)
            obj_.build(child_)
            self.ParameterValue.append(obj_)
            obj_.original_tagname_ = "ParameterValue"
        elif nodeName == "Notes":
            value_ = child_.text

            self.Notes = value_
            self.Notes_nsprefix_ = child_.prefix


class ParentMaterialType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, id: str = None, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.id = _cast(None, id)
        self.id_nsprefix_ = None

    def factory(*args_, **kwargs):

        return ParentMaterialType(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_id(self):
        return self.id

    def set_id(self, id):
        self.id = id

    idProp = property(get_id, set_id)

    def has__content(self):
        if ():
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="ParentMaterialType",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "ParentMaterialType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile,
            level,
            already_processed,
            namespaceprefix,
            name_="ParentMaterialType",
        )
        if self.has__content():
            outfile.write(">%s" % (eol,))

            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportAttributes(
        self,
        outfile,
        level,
        already_processed,
        namespaceprefix="",
        name_="ParentMaterialType",
    ):
        if self.id is not None and "id" not in already_processed:
            already_processed.add("id")
            outfile.write(" id=%s" % (quote_attrib(self.id)))

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]

        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("id", node)
        if value is not None and "id" not in already_processed:
            already_processed.add("id")
            self.id = value


class SymbolType(GeneratedsSuper):
    """This element declares the content model for `Symbol`, which contains the symbol for the chemical element. The entry for `Symbol` is selected from among the strings enumerated by the `ChemicalElementSymbol` datatype.

    `Symbol` has one optional attribute, `subscript`, for indicating the subscript (formula units) of the chemical element.
    """

    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, subscript="1", valueOf_=None, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.subscript = _cast(None, subscript)
        self.subscript_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs):

        return SymbolType(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_subscript(self):
        return self.subscript

    def set_subscript(self, subscript):
        self.subscript = subscript

    subscriptProp = property(get_subscript, set_subscript)

    def get_valueOf_(self):
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def has__content(self):
        if 1 if type(self.valueOf_) in [int, float] else self.valueOf_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="SymbolType",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "SymbolType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="SymbolType"
        )
        outfile.write(">")

        outfile.write(quote_xml(self.valueOf_))
        outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix="", name_="SymbolType"
    ):
        if self.subscript != "1" and "subscript" not in already_processed:
            already_processed.add("subscript")
            outfile.write(" subscript=%s" % (quote_attrib(self.subscript),))

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]

        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("subscript", node)
        if value is not None and "subscript" not in already_processed:
            already_processed.add("subscript")
            self.subscript = value


class GraphType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, anytypeobjs_=None, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        if anytypeobjs_ is None:
            self.anytypeobjs_ = []
        else:
            self.anytypeobjs_ = anytypeobjs_

    def factory(*args_, **kwargs):

        return GraphType(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_anytypeobjs_(self):
        return self.anytypeobjs_

    def set_anytypeobjs_(self, anytypeobjs_):
        self.anytypeobjs_ = anytypeobjs_

    def add_anytypeobjs_(self, value):
        self.anytypeobjs_.append(value)

    def insert_anytypeobjs_(self, index, value):
        self.anytypeobjs_[index] = value

    def has__content(self):
        if self.anytypeobjs_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="GraphType",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "GraphType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )

        if self.has__content():
            outfile.write(">%s" % (eol,))
            self._exportChildren(
                outfile,
                level + 1,
                namespaceprefix,
                namespacedef,
                name_="GraphType",
                pretty_print=pretty_print,
            )
            showIndent(outfile, level, pretty_print)
            outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))
        else:
            outfile.write("/>%s" % (eol,))

    def _exportChildren(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="GraphType",
        fromsubclass_=False,
        pretty_print=True,
    ):
        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if not fromsubclass_:
            for obj_ in self.anytypeobjs_:
                showIndent(outfile, level, pretty_print)
                outfile.write(str(obj_))
                outfile.write("\n")

    def build(self, node):

        self.ns_prefix_ = node.prefix

        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]
            self._buildChildren(child, node, nodeName)
        return self

    def _buildChildren(self, child_, node, nodeName, fromsubclass_=False):
        content_ = etree.tostring(child_, encoding="unicode")
        self.anytypeobjs_.append(content_)


class DataType(GeneratedsSuper):
    __hash__ = GeneratedsSuper.__hash__
    subclass = None
    superclass = None

    def __init__(self, format=None, valueOf_=None, **kwargs):

        self.gds_elementtree_node = None
        self.original_tagname_ = None
        self.parent_object_ = kwargs.get("parent_object_")
        self.ns_prefix_ = None
        self.format = _cast(None, format)
        self.format_nsprefix_ = None
        self.valueOf_ = valueOf_

    def factory(*args_, **kwargs):

        return DataType(*args_, **kwargs)

    factory = staticmethod(factory)

    def get_ns_prefix_(self):
        return self.ns_prefix_

    def set_ns_prefix_(self, ns_prefix):
        self.ns_prefix_ = ns_prefix

    def get_format(self):
        return self.format

    def set_format(self, format):
        self.format = format

    formatProp = property(get_format, set_format)

    def get_valueOf_(self, delimiter=","):
        data_format = self.get_format()
        try:
            # Use the parent's delimiter if it exists. If the attribute exists,
            # but is None, then the delimiter is by default ','.
            delimiter = (
                ","
                if self.parent_object_.delimiter is None
                else self.parent_object_.delimiter
            )
        except AttributeError:
            try:
                # If the parent doesn't have an attribute called `delimiter`,
                # then check the grandparent and try again.
                delimiter = (
                    ","
                    if self.parent_object_.parent_object_.delimiter is None
                    else self.parent_object_.parent_object_.delimiter
                )
            except AttributeError:
                # Otherwise... turn to the default.
                delimeter = ","
        match data_format:
            case "float":
                return [float(item) for item in self.valueOf_.split(delimiter)]
            case "integer":
                return [int(item) for item in self.valueOf_.split(delimiter)]
            case "string":
                return [str(item) for item in self.valueOf_.split(delimiter)]
            case "exponential":
                return [float(item) for item in self.valueOf_.split(delimiter)]
            case "mixed":
                return [str(item) for item in self.valueOf_.split(delimiter)]
            case _:
                try:
                    return [float(item) for item in self.valueOf_.split(delimiter)]
                except ValueError:
                    return [str(item) for item in self.valueOf_.split(delimiter)]
        return self.valueOf_

    def set_valueOf_(self, valueOf_):
        self.valueOf_ = valueOf_

    def has__content(self):
        if 1 if type(self.valueOf_) in [int, float] else self.valueOf_:
            return True
        else:
            return False

    def export(
        self,
        outfile,
        level,
        namespaceprefix="",
        namespacedef="",
        name_="DataType",
        pretty_print=True,
    ):

        if pretty_print:
            eol = "\n"
        else:
            eol = ""
        if self.original_tagname_ is not None and name_ == "DataType":
            name_ = self.original_tagname_
        if UseCapturedNS_ and self.ns_prefix_:
            namespaceprefix = self.ns_prefix_ + ":"
        showIndent(outfile, level, pretty_print)
        outfile.write(
            "<%s%s%s"
            % (
                namespaceprefix,
                name_,
                namespacedef and " " + namespacedef or "",
            )
        )
        already_processed = set()
        self._exportAttributes(
            outfile, level, already_processed, namespaceprefix, name_="DataType"
        )
        outfile.write(">")

        outfile.write(quote_xml(self.valueOf_))
        outfile.write("</%s%s>%s" % (namespaceprefix, name_, eol))

    def _exportAttributes(
        self, outfile, level, already_processed, namespaceprefix="", name_="DataType"
    ):
        if self.format is not None and "format" not in already_processed:
            already_processed.add("format")
            outfile.write(" format=%s" % (quote_attrib(self.format),))

    def build(self, node):

        already_processed = set()
        self.ns_prefix_ = node.prefix
        self._buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName = Tag_pattern_.match(child.tag).groups()[-1]

        return self

    def _buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_("format", node)
        if value is not None and "format" not in already_processed:
            already_processed.add("format")
            self.format = value


__all__ = [
    "AssociationDetails",
    "AuthorityDetails",
    "BulkDetails",
    "Characterization",
    "ChemicalComposition",
    "Class",
    "ComponentDetails",
    "Compound",
    "Concentration",
    "DataSourceDetails",
    "DataType",
    "DataType",
    "DimensionalDetails",
    "Element",
    "Form",
    "Geometry",
    "Glossary",
    "GlossaryTerm",
    "GraphType",
    "Graphs",
    "MatML_Doc",
    "Material",
    "MeasurementTechniqueDetails",
    "Metadata",
    "Name",
    "ParameterDetails",
    "ParameterValue",
    "ParentMaterialType",
    "PhaseComposition",
    "ProcessingDetails",
    "PropertyData",
    "PropertyDetails",
    "Source",
    "SourceDetails",
    "Specification",
    "SpecimenDetails",
    "SymbolType",
    "TestConditionDetails",
    "Uncertainty",
    "Unit",
    "Unitless",
    "Units",
    "Value",
]
